#!/usr/bin/env perl
### gatk.pl ########################################################################################
use AutoLoader 'AUTOLOAD';
use strict;
use warnings;
use Carp;
use POSIX qw(strftime);
use Getopt::Std;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path);
use YAML qw(LoadFile);

my $cwd = dirname($0);
require "$cwd/shared/utilities.pl";

# define some global variables
our ($data_type, $reference, $known_1000g, $known_mills, $dbsnp);

####################################################################################################
# version       author	  	comment
# 1.1		sprokopec	run GATKs indel realignment and recalibration on BWA aligned bams
# 1.2		sprokopec	added functionality for processing of STAR-aligned RNA-Seq bams

### USAGE ##########################################################################################
# gatk.pl -t tool_config.yaml -c data_config.yaml --dna (or --rna)
#
# where:
#	- tool_config.yaml contains tool versions and parameters, output directory,
#	reference information, etc.
#	- data_config.yaml contains sample information (YAML file containing paths to BWA-aligned BAMs,
#	generated by create_final_yaml.pl)
#	--dna (or --rna) to indicate whether input is DNA (BWA) or RNA (STAR) based

### SUBROUTINES ####################################################################################
# format command to split Cigar Reads
sub get_split_command {
	my %args = (
		input		=> undef,
		output		=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $split_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T SplitNCigarReads',
		'-R', $reference,
		'-I', $args{input},
		'-o', $args{output},
		'-rf ReassignOneMappingQuality -rf UnmappedRead',
		'-RMQF 255 -RMQT 60 -U ALLOW_N_CIGAR_READS',
		'--generate_md5'
		);

	return($split_command);
	}

# format command to run GATK RealignerTargetCreatro
sub get_target_intervals_command {
	my %args = (
		input		=> undef,
		n_samples	=> 1,
		output		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $target_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T RealignerTargetCreator',
		'-R', $reference,
		'-I', $args{input},
		'-o', $args{output},
		'-known', $known_1000g,
		'-known', $known_mills
		);

	# if this is DNA data, add additional options
	if ('dna' eq $data_type) {
		$target_command = join(' ',
			$target_command,
			'--disable_auto_index_creation_and_locking_when_reading_rods -nt', $args{n_samples}
			);

		if ('' ne $args{intervals}) {
			$target_command = join(' ',
				$target_command,
				'--intervals', $args{intervals},
				'--interval_padding 100'
				);
			}
		}

	return($target_command);
	}

# format command to run GATK IndelRealigner
sub get_indelrealign_command {
	my %args = (
		input		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		output		=> undef,
		@_
		);

	my $realign_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T IndelRealigner',
		'-I', $args{input},
		'-R', $reference,
		'-targetIntervals', $args{intervals}
		);

	# if this is DNA data, add additional options
	if ('dna' eq $data_type) {

		$realign_command = join(' ',
			$realign_command,
			'--disable_auto_index_creation_and_locking_when_reading_rods',
			'-nWayOut _realigned.bam',
			'-known', $known_1000g,
			'-known', $known_mills,
			'-compress 0'
			);

		# otherwise, it is RNA, so add these options
		} elsif ('rna' eq $data_type) {

		$realign_command = join(' ',
			$realign_command,
			'-o', $args{output},
			'--generate_md5'
			);
		}

	return($realign_command);
	}

# format command to run GATK BaseRecalibrator
sub create_recalibration_table {
	my %args = (
		input		=> undef,
		output		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $bqsr_command = join(' ', 
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T BaseRecalibrator',
		'-I', $args{input},
		'-R', $reference,
		'-knownSites', $known_1000g,
		'-knownSites', $known_mills,
		'-o', $args{output}
		);

	# if this is DNA data, add additional options
	if ('dna' eq $data_type) {

		$bqsr_command = join(' ',
			$bqsr_command,
			'--disable_auto_index_creation_and_locking_when_reading_rods -nct 8',
			'-rf BadCigar',
			'--covariate ReadGroupCovariate',
			'--covariate QualityScoreCovariate',
			'--covariate CycleCovariate',
			'--covariate ContextCovariate'
			);

		if ('' ne $args{intervals}) {
			$bqsr_command = join(' ',
				$bqsr_command,
				'--intervals', $args{intervals},
				'--interval_padding 100'
				);
			}

		# otherwise, it is RNA, so add these options
		} elsif ('rna' eq $data_type) {

		$bqsr_command = join(' ',
			$bqsr_command,
			'-knownSites', $dbsnp,
			);
		}

	return($bqsr_command);
	}

# format command to run GATK PrintReads
sub create_recalibrated_bam {
	my %args = (
		input		=> undef,
		bqsr		=> undef,
		output		=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $recal_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T PrintReads',
		'-I', $args{input},
		'-R', $reference,
		'-BQSR', $args{bqsr},
		'-o', $args{output},
		'--generate_md5'
		);

	# if this is DNA data, add additional options
	if ('dna' eq $data_type) {

		$recal_command = join(' ',
			$recal_command,
			'--disable_auto_index_creation_and_locking_when_reading_rods -nct 8',
			'-rf BadCigar'
			);
		}

	return($recal_command);
	}

### RUN ############################################################################################
sub main {
	my %args = (
		tool_config	=> undef,
		data_config	=> undef,
		data_type	=> undef,
		@_
		);

	my $tool_config = $args{tool_config};
	my $data_config = $args{data_config};
	my $data_type = $args{data_type};

	### PREAMBLE ######################################################################################

	# load tool config
	my $tool_data_orig = LoadFile($tool_config);
	my $tool_data = error_checking(tool_data => $tool_data_orig, pipeline => 'gatk', data_type => $data_type);
	$tool_data->{date} = strftime "%F", localtime;

	# check for resume and confirm output directories
	my ($resume, $output_directory, $log_directory) = set_output_path(tool_data => $tool_data);

	# start logging
	print "---\n";
	if ('dna' eq $data_type) {
		print "Running GATK pipeline for BWA-aligned DNA data.\n";
		} elsif ('rna' eq $data_type) {
		print "Running GATK pipeline for STAR-aligned RNA-Seq data.\n";
		}
	print "\n  Tool config used: $tool_config";
	print "\n    Reference: $tool_data->{reference}";

	$reference = $tool_data->{reference};
	if ('hg38' eq $tool_data->{ref_type}) {

		print "\n      Using GATK's hg38bundle files: /cluster/tools/data/genomes/human/hg38/hg38bundle/";
		$known_1000g	= '/cluster/tools/data/genomes/human/hg38/hg38bundle/1000G_phase1.snps.high_confidence.hg38.vcf.gz';
		$known_mills	= '/cluster/tools/data/genomes/human/hg38/hg38bundle/Mills_and_1000G_gold_standard.indels.hg38.vcf.gz';
		$dbsnp		= '/cluster/tools/data/genomes/human/hg38/hg38bundle/dbsnp_144.hg38.vcf.gz';

		} elsif ('hg19' eq $tool_data->{ref_type}) {

		print "\n      Using hg19 variant calling files: /cluster/tools/data/genomes/human/hg19/variantcallingdata/";
		$known_1000g	= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/1000G_phase1.snps.high_confidence.hg19.vcf';
		$known_mills	= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/Mills_and_1000G_gold_standard.indels.hg19.vcf';
		$dbsnp		= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/dbsnp_138.hg19.vcf';

		}

	if (defined($tool_data->{dbsnp})) {
		print "\n      dbSNP: $tool_data->{dbsnp}";
		$dbsnp = $tool_data->{dbsnp};
		} else {
		print "\n      dbSNP: using default provided in above path (v138 for hg19; v144 for hg38)";
		}

	if (defined($tool_data->{intervals_bed})) {
		print "\n    Target intervals (exome): $tool_data->{intervals_bed}";
		}

	print "\n    Output directory: $output_directory";
	print "\n  Sample config used: $data_config";
	print "\n---";

	# set tools and versions
	my $gatk = $tool_data->{tool} . '/' . $tool_data->{tool_version};
	my $samtools = 'samtools/' . $tool_data->{samtools_version};
	my $picard = 'picard/' . $tool_data->{picard_version};

	# create a file to hold job metrics
	my (@files, $run_count, $outfile, $touch_exit_status);
	if ('N' eq $tool_data->{dry_run}) {
		# initiate a file to hold job metrics (ensures that an existing file isn't overwritten by concurrent jobs)
		opendir(LOGFILES, $log_directory) or die "Cannot open $log_directory";
		@files = grep { /slurm_job_metrics/ } readdir(LOGFILES);
		$run_count = scalar(@files) + 1;
		closedir(LOGFILES);

		$outfile = $log_directory . '/slurm_job_metrics_' . $run_count . '.out';
		$touch_exit_status = system("touch $outfile");
		if (0 != $touch_exit_status) { Carp::croak("Cannot touch file $outfile"); }
		}

	### HANDLING FILES #################################################################################
	# get sample data
	my $smp_data = LoadFile($data_config);

	my ($run_script, $run_id, $run_id2, $link);
	my @all_jobs;

	# process each patient in $smp_data
	foreach my $patient (sort keys %{$smp_data}) {

		print "\nInitiating process for PATIENT: $patient\n";

		# make a sample-specific directory
		my $patient_directory = join('/', $output_directory, $patient);
		unless(-e $patient_directory) { make_path($patient_directory); }

		# find sample IDs and paths to BAM input files
		my @normal_ids = keys %{$smp_data->{$patient}->{'normal'}};
		my @tumour_ids = keys %{$smp_data->{$patient}->{'tumour'}};
		my @normal_paths = values %{$smp_data->{$patient}->{'normal'}};
		my @tumour_paths = values %{$smp_data->{$patient}->{'tumour'}};

		my @samples = @tumour_ids;
		if (scalar(@normal_ids) > 0) { push @samples, @normal_ids; }

		# initiate some variables
		my (@final_outputs, @patient_jobs);
		$run_id = '';

		# make a directory for intermediate files
		my $intermediate_directory = join('/', $patient_directory, 'intermediate_files');
		unless(-e $intermediate_directory) { make_path($intermediate_directory); }

		# make a TEMP directory
		my $tmp_directory = join('/', $patient_directory, 'TEMP');
		unless(-e $tmp_directory) { make_path($tmp_directory); }
		my $cleanup_cmd = "rm -rf $tmp_directory";

		# make a directory to link input files
		my $raw_directory = join('/', $patient_directory, 'bam_links');
		unless(-e $raw_directory) { make_path($raw_directory); }

		# create symlinks for the input files
		my @input_bams;
		foreach my $bam (@normal_paths) {
			my @tmp = split /\//, $bam;
			$link = join('/', $raw_directory, $tmp[-1]);
			symlink($bam, $link);
			push @input_bams, $tmp[-1];
			}

		foreach my $bam (@tumour_paths) {
			my @tmp = split /\//, $bam;
			$link = join('/', $raw_directory, $tmp[-1]);
			symlink($bam, $link);
			push @input_bams, $tmp[-1];
			}

		## for DNA, indel realigner target creation and indel realigner use all patient input files
		my ($input_string, $target_intervals, $stage1_cmd, $stage2_cmd);
		my @realign_bams_dna;

		if ('dna' eq $data_type) {

			# combine input paths to a single string
			if (scalar(@normal_paths) > 0) {
				$input_string .=  join(' -I ', @normal_paths);
				}
			if ( (scalar @normal_paths > 0) & (scalar @tumour_paths > 0) ) {
				$input_string .= ' -I ';
				}
			if (scalar @tumour_paths > 0) {
				$input_string .= join(' -I ', @tumour_paths);
				}

			## RealignerTargetCreator
			$target_intervals = join('/', $intermediate_directory, $patient . '_target.intervals');
			$stage1_cmd = get_target_intervals_command(
				input		=> $input_string,
				n_samples	=> scalar(@input_bams),
				output		=> $target_intervals,
				intervals	=> $tool_data->{intervals_bed},
				java_mem	=> $tool_data->{parameters}->{target_creator}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			$stage1_cmd .= ";\nmd5sum $target_intervals > $target_intervals.md5";

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($target_intervals . '.md5'))) {

				# record command (in log directory) and then run job
				print "Submitting job for RealignerTargetCreator...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_indel_realigner_target_creator_' . $patient,
					cmd	=> $stage1_cmd,
					modules	=> [$gatk]
					);

				$run_id = submit_job(
					jobname		=> 'run_indel_realigner_target_creator_' . $patient,
					shell_command	=> $run_script,
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{target_creator}->{time},
					mem		=> $tool_data->{parameters}->{target_creator}->{mem},
					cpus_per_task	=> scalar(@input_bams),
					hpc_driver	=> $tool_data->{HPC_driver},
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id;
				push @all_jobs, $run_id;
				}
			else {
				print "Skipping RealignerTargetCreator because this has already been completed!\n";
				}

			## IndelRealigner
			$stage2_cmd = get_indelrealign_command(
				input		=> $input_string,
				intervals	=> $target_intervals,
				java_mem	=> $tool_data->{parameters}->{realign}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			$stage2_cmd = "cd $intermediate_directory;\n$stage2_cmd;";

			foreach my $inbam (@input_bams) {
				my $outbam = $inbam; 
				$outbam =~ s/.bam/_realigned.bam/; 
				$stage2_cmd .= "\nmd5sum $outbam > $outbam.md5;";
				push @realign_bams_dna, join('/', $intermediate_directory, $outbam);

				$outbam = join('/', $intermediate_directory, $outbam);
				my $outbai = $outbam;
				$outbai =~ s/bam$/bai/;
				$cleanup_cmd .= ";\nrm " . $outbam;
				$cleanup_cmd .= ";\nrm " . $outbai;
				}

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($realign_bams_dna[-1] . '.md5'))) {

				# record command (in log directory) and then run job
				print "Submitting job for IndelRealigner...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_indel_realigner_' . $patient,
					cmd	=> $stage2_cmd,
					modules	=> [$gatk]
					);

				$run_id = submit_job(
					jobname		=> 'run_indel_realigner_' . $patient,
					shell_command	=> $run_script,
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{realign}->{time},
					mem		=> $tool_data->{parameters}->{realign}->{mem},
					hpc_driver	=> $tool_data->{HPC_driver},
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id;
				push @all_jobs, $run_id;
				}
			else {
				print "Skipping IndelRealigner because this has already been completed!\n";
				}
			}

		# Run per-sample steps (BQSR for DNA, all for RNA)
		foreach my $sample (@samples) {

			# determine sample type
			my $type;
			if ($sample =~ m/BC|SK|A/) { $type = 'normal'; } else { $type = 'tumour'; }

			# initiate some variables
			my ($realigned_bam, $realigned_bai);

			if ('rna' eq $data_type) {

				print "  SAMPLE: $sample\n\n";

				my $aligned_bam = $smp_data->{$patient}->{$type}->{$sample};

				## first, split cigar reads
				my $split_bam = join('/', $intermediate_directory, $sample . '_split.bam');
				my $split_bai = join('/', $intermediate_directory, $sample . '_split.bai');

				my $split_cmd = get_split_command(
					input		=> $aligned_bam,
					output		=> $split_bam,
					java_mem	=> $tool_data->{parameters}->{split_cigar}->{java_mem},
					tmp_dir		=> $tmp_directory
					);

				$cleanup_cmd .= ";\nrm " . $split_bam;
				$cleanup_cmd .= ";\nrm " . $split_bai;

				# check if this should be run
				if ( ('N' eq $resume) || ('Y' eq missing_file($split_bam . '.md5')) ) {

					# record command (in log directory) and then run job
					print "Submitting job for SplitNCigarReads...\n";

					$run_script = write_script(
						log_dir	=> $log_directory,
						name	=> 'run_split_cigar_' . $sample,
						cmd	=> $split_cmd,
						modules	=> [$gatk]
						);

					$run_id = submit_job(
						jobname		=> 'run_split_cigar_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{split_cigar}->{time},
						mem		=> $tool_data->{parameters}->{split_cigar}->{mem},
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id;
					push @all_jobs, $run_id;
					}
				else {
					print "Skipping SplitNCigarReads because this has already been completed!\n";
					}

				# create target intervals
				$target_intervals = join('/', $intermediate_directory, $sample . '_target.intervals');

				$stage1_cmd = get_target_intervals_command(
					input		=> $split_bam,
					output		=> $target_intervals,
					java_mem	=> $tool_data->{parameters}->{target_creator}->{java_mem},
					tmp_dir		=> $tmp_directory
					);

				$stage1_cmd .= ";\nmd5sum " . join(' ', $target_intervals, '>', $target_intervals . '.md5');

				# check if this should be run
				if ( ('N' eq $resume) || ('Y' eq missing_file($target_intervals . '.md5')) ) {

					# record command (in log directory) and then run job
					print "Submitting job for RealignerTargetCreator...\n";

					$run_script = write_script(
						log_dir	=> $log_directory,
						name	=> 'run_indel_realigner_target_creator_' . $sample,
						cmd	=> $stage1_cmd,
						modules	=> [$gatk]
						);

					$run_id = submit_job(
						jobname		=> 'run_indel_realigner_target_creator_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{target_creator}->{time},
						mem		=> $tool_data->{parameters}->{target_creator}->{mem},
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id;
					push @all_jobs, $run_id;
					}
				else {
					print "Skipping RealignerTargetCreator because this has already been completed!\n";
					}

				# perform indel realignment
				$realigned_bam = join('/', $intermediate_directory, $sample . '_split_realigned.bam');
				$realigned_bai = join('/', $intermediate_directory, $sample . '_split_realigned.bai');

				$stage2_cmd = get_indelrealign_command(
					input		=> $split_bam,
					output		=> $realigned_bam,
					intervals	=> $target_intervals,
					java_mem	=> $tool_data->{parameters}->{realign}->{java_mem},
					tmp_dir		=> $tmp_directory
					);

				$cleanup_cmd .= ";\nrm " . $realigned_bam;
				$cleanup_cmd .= ";\nrm " . $realigned_bai;

				# check if this should be run
				if ( ('N' eq $resume) || ('Y' eq missing_file($realigned_bam . '.md5')) ) {

					# record command (in log directory) and then run job
					print "Submitting job for IndelRealigner...\n";

					$run_script = write_script(
						log_dir	=> $log_directory,
						name	=> 'run_indel_realigner_' . $sample,
						cmd	=> $stage2_cmd,
						modules	=> [$gatk]
						);

					$run_id = submit_job(
						jobname		=> 'run_indel_realigner_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{realign}->{time},
						mem		=> $tool_data->{parameters}->{realign}->{mem},
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id;
					push @all_jobs, $run_id;
					}
				else {
					print "Skipping IndelRealigner because this has already been completed!\n";
					}
				}

			## BaseRecalibrator
			print "Performing base recalibration steps for: $sample\n";

			my $bqsr_file = join('/', $intermediate_directory, $sample . '.recal_data.grp');

			if ('dna' eq $data_type) {
				my @tmp = grep { /$sample/ } @realign_bams_dna;
				$realigned_bam = $tmp[0];
				}
 
			my $stage3_cmd = create_recalibration_table(
				input		=> $realigned_bam,
				output		=> $bqsr_file,
				intervals	=> $tool_data->{intervals_bed},
				java_mem	=> $tool_data->{parameters}->{bqsr}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($bqsr_file)) ) {

				# record command (in log directory) and then run job
				print "\nSubmitting job for BaseRecalibrator...";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_base_quality_score_recalibrator_' . $sample,
					cmd	=> $stage3_cmd,
					modules	=> [$gatk]
					);

				if ('dna' eq $data_type) {

					$run_id2 = submit_job(
						jobname		=> 'run_base_quality_score_recalibrator_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{bqsr}->{time}->{$type},
						mem		=> $tool_data->{parameters}->{bqsr}->{mem},
						cpus_per_task	=> 8,
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id2;
					push @all_jobs, $run_id2;

					}

				elsif ('rna' eq $data_type) {

					$run_id = submit_job(
						jobname		=> 'run_base_quality_score_recalibrator_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{bqsr}->{time}->{$type},
						mem		=> $tool_data->{parameters}->{bqsr}->{mem},
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id;
					push @all_jobs, $run_id;
					}
				}
			else {
				print "Skipping BaseRecalibrator because this has already been completed!\n";
				}

			## PrintReads
			my $recal_bam = join('/', $patient_directory, $sample . '_realigned_recalibrated.bam');

			my $stage4_cmd = create_recalibrated_bam(
				input		=> $realigned_bam,
				bqsr		=> $bqsr_file,
				output		=> $recal_bam,
				java_mem	=> $tool_data->{parameters}->{recalibrate}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($recal_bam . '.md5'))) {

				# record command (in log directory) and then run job
				print "Submitting job for PrintReads (applying base recalibration)...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_apply_base_recalibration_' . $sample,
					cmd	=> $stage4_cmd,
					modules	=> [$gatk]
					);

				if ('dna' eq $data_type) {

					$run_id2 = submit_job(
						jobname		=> 'run_apply_base_recalibration_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id2,
						max_time	=> $tool_data->{parameters}->{recalibrate}->{time}->{$type},
						mem		=> $tool_data->{parameters}->{recalibrate}->{mem},
						cpus_per_task	=> 8,
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id2;
					push @all_jobs, $run_id2;

					}

				elsif ('rna' eq $data_type) {

					$run_id = submit_job(
						jobname		=> 'run_apply_base_recalibration_' . $sample,
						shell_command	=> $run_script,
						dependencies	=> $run_id,
						max_time	=> $tool_data->{parameters}->{recalibrate}->{time}->{$type},
						mem		=> $tool_data->{parameters}->{recalibrate}->{mem},
						hpc_driver	=> $tool_data->{HPC_driver},
						dry_run		=> $tool_data->{dry_run}
						);

					push @patient_jobs, $run_id;
					push @all_jobs, $run_id;
					}
				}
			else {
				print "Skipping PrintReads (apply base recalibration) because this has already been completed!\n";
				}

			push @final_outputs, $recal_bam;
			}

		# clean up/remove intermediate files
		if ('Y' eq $tool_data->{del_intermediate}) {

			print "Submitting job to clean up temporary/intermediate files...\n";

			$run_script = write_script(
				log_dir	=> $log_directory,
				name	=> 'run_cleanup_' . $patient,
				cmd	=> $cleanup_cmd
				);

			$run_id = submit_job(
				jobname		=> 'run_cleanup_' . $patient,
				shell_command	=> $run_script,
				dependencies	=> join(',', @patient_jobs),
				max_time	=> '00:05:00',
				mem		=> '256M',
				hpc_driver	=> $tool_data->{HPC_driver},
				dry_run		=> $tool_data->{dry_run}
				);
			}

		print "FINAL OUTPUT:\n" . join("\n  ", @final_outputs) . "\n";
		print "---\n";
		}

	# if this is not a dry run, collect job metrics (exit status, mem, run time)
	if ('N' eq $tool_data->{dry_run}) {

		# collect job metrics
		my $collect_metrics = collect_job_stats(
			job_ids	=> join(',', @all_jobs),
			outfile	=> $outfile
			);

		$run_script = write_script(
			log_dir	=> $log_directory,
			name	=> 'output_job_metrics_' . $run_count,
			cmd	=> $collect_metrics
			);

		$run_id = submit_job(
			jobname		=> 'output_job_metrics',
			shell_command	=> $run_script,
			dependencies	=> join(',', @all_jobs),
			max_time	=> '0:10:00',
			mem		=> '1G',
			hpc_driver	=> $tool_data->{HPC_driver},
			dry_run		=> $tool_data->{dry_run}
			);
		}

	# final job to output a BAM config for downstream stuff
	if ('Y' eq $tool_data->{create_output_yaml}) {

		print "Creating config yaml for GATK-processed BAM files...\n";

		my $output_yaml_cmd = join(' ',
			"perl $cwd/shared/create_final_yaml.pl",
			'-d', $output_directory,
			'-o', $output_directory . '/bam_config.yaml',
			'-p', 'recalibrated.bam$'
			);

		$run_script = write_script(
			log_dir	=> $log_directory,
			name	=> 'output_final_yaml',
			cmd	=> $output_yaml_cmd,
			modules	=> ['perl']
			);

		$run_id = submit_job(
			jobname		=> 'output_final_yaml',
			shell_command	=> $run_script,
			dependencies	=> join(',', @all_jobs),
			max_time	=> '0:10:00',
			mem		=> '1G',
			hpc_driver	=> $tool_data->{HPC_driver},
			dry_run		=> $tool_data->{dry_run}
			);

		} else {
			print "Not creating output config yaml as requested...\n";
		}

	# finish up
	print "\nProgramming terminated successfully.\n\n";

	}

### GETOPTS AND DEFAULT VALUES #####################################################################
# declare variables
my $tool_config;
my $data_config;
my ($dna, $rna);

# read in command line arguments
GetOptions(
	't|tool=s'	=> \$tool_config,
	'c|config=s'	=> \$data_config,
	'dna'		=> \$dna,
	'rna'		=> \$rna
	);

# quick error checks to confirm valid arguments
if (!defined($tool_config)) { die("No tool config file defined; please provide -t | --tool (ie, tool_config.yaml)"); }
if (!defined($data_config)) { die("No data config file defined; please provide -c | --config (ie, sample_config.yaml)"); }

if ($dna && $rna) {
	die("Please don't set both --dna and --rna; can only be one of these!");
	} elsif ($dna) {
	$data_type = 'dna';
	} elsif ($rna) {
	$data_type = 'rna';
	} else {
	die("No data type set; please set one of --dna or --rna to proceed!");
	}

# run it!
main(tool_config => $tool_config, data_config => $data_config, data_type => $data_type);
