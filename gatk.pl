#!/usr/bin/env perl
### gatk.pl ########################################################################################
use AutoLoader 'AUTOLOAD';
use strict;
use warnings;
use Carp;
use POSIX qw(strftime);
use Getopt::Std;
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path);
use YAML qw(LoadFile);

my $cwd = dirname($0);
require "$cwd/shared/utilities.pl";

####################################################################################################
# version       author	  	comment
# 1.0		sprokopec	run GATKs indel realignment and recalibration on BWA aligned bams

### USAGE ##########################################################################################
# run_gatk_processing.pl -t tool_config.yaml -c data_config.yaml
#
# where:
#	- tool_config.yaml contains tool versions and parameters, output directory,
#	reference information, etc.
#	- data_config.yaml contains sample information (YAML file containing paths to BWA-aligned BAMs,
#	generated by create_bam_yaml.pl)

### SUBROUTINES ####################################################################################
# format command to run GATK RealignerTargetCreatro
sub get_target_intervals_command {
	my %args = (
		input		=> undef,
		n_samples	=> 1,
		output		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $target_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T RealignerTargetCreator',
		'--disable_auto_index_creation_and_locking_when_reading_rods -nt', $args{n_samples},
		'-R', $reference,
		'-I', $args{input},
		'-o', $args{output},
		'-known', $known_1000g,
		'-known', $known_mills
		);

	if ('' ne $intervals) {
		$target_command = join(' ',
			$target_command,
			'--intervals', $args{intervals},
			'--interval_padding 100'
			);
		}

	return($target_command);
	}

# format command to run GATK IndelRealigner
sub get_indelrealign_command {
	my %args = (
		input		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $realign_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T IndelRealigner',
		'--disable_auto_index_creation_and_locking_when_reading_rods',
		'-I', $args{input},
		'-nWayOut _realigned.bam',
		'-R', $reference,
		'-targetIntervals', $args{intervals},
		'-known', $known_1000g,
		'-known', $known_mills,
		'-compress 0'
		);

	return($realign_command);
	}

# format command to run GATK BaseRecalibrator
sub create_recalibration_table {
	my %args = (
		input		=> undef,
		output		=> undef,
		intervals	=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $gatk_command = join(' ', 
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T BaseRecalibrator',
		'--disable_auto_index_creation_and_locking_when_reading_rods -nct 8',
		'-I', $args{input},
		'-R', $reference,
		'-knownSites', $known_1000g,
		'-knownSites', $known_mills,
		'-o', $args{output},
		'-rf BadCigar',
		'--covariate ReadGroupCovariate',
		'--covariate QualityScoreCovariate',
		'--covariate CycleCovariate',
		'--covariate ContextCovariate'
		);

	if ('' ne $intervals) {
		$gatk_command = join(' ',
			$gatk_command,
			'--intervals', $args{intervals},
			'--interval_padding 100'
			);
		}

	return($gatk_command);
	}

# format command to run GATK PrintReads
sub create_recalibrated_bam {
	my %args = (
		input		=> undef,
		bqsr		=> undef,
		output		=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $recal_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T PrintReads',
		'--disable_auto_index_creation_and_locking_when_reading_rods -nct 8',
		'-I', $args{input},
		'-R', $reference,
		'-BQSR', $args{bqsr},
		'-o', $args{output},
		'-rf BadCigar',
		'--generate_md5'
		);
	}

sub main {
	my %args = (
		tool_config => undef,
		data_config => undef,
		@_
		);

	my $tool_config = $args{tool_config};
	my $data_config = $args{data_config};

	my $date = strftime "%F", localtime;

	### PREAMBLE ######################################################################################

	if (!defined($tool_config)) { die("No tool config file defined; please provide -t | --tool (ie, tool_config.yaml)"); }
	if (!defined($data_config)) { die("No data config file defined; please provide -c | --config (ie, sample_config.yaml)"); }

	# load tool config
	my $tool_data = LoadFile($tool_config);

	# do some quick checks for required info
	my $reference;
	if (!defined($tool_data->{reference})) 	{
		die("Must supply path to reference genome!");
		} else {
		$reference = $tool_data->{reference};
		}

	# for del_intermediates, if not Y then default to N
	if (('Y' ne $tool_data->{del_intermediate}) & ('N' ne $tool_data->{del_intermediate})) {
		print "Option del_intermediate is neither Y or N, defaulting to N\n";
		$tool_data->{del_intermediate} = 'N';
		}

	# start logging
	print "---\n";
	print "Running GATK pipeline for BWA-aligned data.\n";
	print "\n  Tool config used: $tool_config";
	print "\n    Reference: $reference";

	my ($known_1000g, $known_mills, $dbsnp);
	if ('hg38' eq $tool_data->{ref_type}) {

		print "\n      Using GATK's hg38bundle files: /cluster/tools/data/genomes/human/hg38/hg38bundle/";
		$known_1000g	= '/cluster/tools/data/genomes/human/hg38/hg38bundle/1000G_phase1.snps.high_confidence.hg38.vcf.gz';
		$known_mills	= '/cluster/tools/data/genomes/human/hg38/hg38bundle/Mills_and_1000G_gold_standard.indels.hg38.vcf.gz';
		$dbsnp		= '/cluster/tools/data/genomes/human/hg38/hg38bundle/dbsnp_144.hg38.vcf.gz';

		} elsif ('hg19' eq $tool_data->{ref_type}) {

		print "\n      Using hg19 variant calling files: /cluster/tools/data/genomes/human/hg19/variantcallingdata/";
		$known_1000g	= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/1000G_phase1.snps.high_confidence.hg19.vcf';
		$known_mills	= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/Mills_and_1000G_gold_standard.indels.hg19.vcf';
		$dbsnp		= '/cluster/tools/data/genomes/human/hg19/variantcallingdata/dbsnp_138.hg19.vcf';

		} else {
			die("Unrecognized ref_type; must be one of hg19 or hg38.");
		}

	if (defined($tool_data->{dbsnp})) {
		print "\n      dbSNP: $tool_data->{dbsnp}";
		$dbsnp = $tool_data->{dbsnp};
		} else {
		print "\n      dbSNP: using default provided in above path (v138 for hg19; v144 for hg38)";
		}

	if (defined($tool_data->{intervals_bed})) {
		print "\n    Target intervals (exome): $tool_data->{intervals_bed}";
		}

	print "\n    Output directory: $tool_data->{output_dir}";
	print "\n  Sample config used: $data_config";
	print "\n---";

	# set tools and versions
	my $gatk_version = $tool_data->{tool} . '/' . $tool_data->{tool_version};
	my $samtools = 'samtools/' . $tool_data->{samtools_version};
	my $picard = 'picard/' . $tool_data->{picard_version};

	# check if this is a dry run or not
	if ((!defined($tool_data->{dry_run})) || ('Y' ne $tool_data->{dry_run})) {
		$tool_data->{dry_run} = 'N';
		}

	### CREATE DIRECTORY STRUCTURE ####################################################################
	my $output_directory;
	my $resume = 'N';

	# check for RESUME directory
	if (defined ($tool_data->{resume_dir})) {
		$resume = 'Y';
		$tool_data->{resume_dir} =~ s/\/$//;
		$output_directory = $tool_data->{resume_dir};
		} else {
		# otherwise, make a directory for this batch
		# make sure output directory exists
		unless(-e $tool_data->{output_dir}) { make_path($tool_data->{output_dir}); }

		$tool_data->{output_dir} =~ s/\/$//;
		$output_directory = join('/', $tool_data->{output_dir},  join('_', $date, $tool_data->{tool}, $tool_data->{tool_version}));
		unless(-e $output_directory) { make_path($output_directory); }
		}

	# and directory for log files
	my $log_directory = join('/', $output_directory, 'logs');
	unless(-e $log_directory) { make_path($log_directory); }

	### HANDLING FILES #################################################################################
	# get sample data
	my $smp_data = LoadFile($data_config);

	my ($run_script, $run_id, $run_id2, $link);
	my @all_jobs;

	# process each sample in $smp_data
	foreach my $patient (sort keys %{$smp_data}) {

		print "\nInitiating process for PATIENT: $patient\n";

		# make a sample-specific directory
		my $patient_directory = join('/', $output_directory, $patient);
		unless(-e $patient_directory) { make_path($patient_directory); }

		# make a directory for intermediate files
		my $intermediate_directory = join('/', $patient_directory, 'intermediate_files');
		unless(-e $intermediate_directory) { make_path($intermediate_directory); }

		# make a TEMP directory
		my $tmp_directory = join('/', $patient_directory, 'TEMP');
		unless(-e $tmp_directory) { make_path($tmp_directory); }

		my @normal_ids = keys %{$smp_data->{$patient}->{'normal'}};
		my @tumour_ids = keys %{$smp_data->{$patient}->{'tumour'}};
		my @normal_paths = values %{$smp_data->{$patient}->{'normal'}};
		my @tumour_paths = values %{$smp_data->{$patient}->{'tumour'}};

		my @samples = @tumour_ids;
		if (scalar(@normal_ids) > 0) { push @samples, @normal_ids; }

		my $input_string;
		if (scalar(@normal_paths) > 0) {
			$input_string .=  join(' -I ', @normal_paths);
			}
		if ( (scalar @normal_paths > 0) & (scalar @tumour_paths > 0) ) {
			$input_string .= ' -I ';
			}
		if (scalar @tumour_paths > 0) {
			$input_string .= join(' -I ', @tumour_paths);
			}

		my @input_bams;
		my @final_outputs;

		# create symlinks for the BWA input files
		my $raw_directory = join('/', $patient_directory, 'bwa_links');
		unless(-e $raw_directory) { make_path($raw_directory); }

		foreach my $bam (@normal_paths) {
			my @tmp = split /\//, $bam;
			$link = join('/', $raw_directory, $tmp[-1]);
			symlink($bam, $link);
			push @input_bams, $tmp[-1];
			}

		foreach my $bam (@tumour_paths) {
			my @tmp = split /\//, $bam;
			$link = join('/', $raw_directory, $tmp[-1]);
			symlink($bam, $link);
			push @input_bams, $tmp[-1];
			}

		$run_id = '';
		my @patient_jobs;
		my $cleanup_cmd;

		## RealignerTargetCreator
		my $target_intervals = join('/', $intermediate_directory, $patient . '_target.intervals');
		my $stage1_cmd = get_target_intervals_command(
			input		=> $input_string,
			n_samples	=> scalar(@input_bams),
			output		=> $target_intervals,
			intervals	=> $tool_data->{intervals_bed},
			java_mem	=> $tool_data->{parameters}->{target_creator}->{java_mem},
			tmp_dir		=> $tmp_directory
			);

		$stage1_cmd .= ";\nmd5sum $target_intervals > $target_intervals.md5";

		# check if this should be run
		if ( ('N' eq $resume) || ('Y' eq missing_file($target_intervals . '.md5'))) {
			# record command (in log directory) and then run job
			print "\nSubmitting job for RealignerTargetCreator...";
			$run_script = write_script(
				log_dir	=> $log_directory,
				name	=> 'run_indel_realigner_target_creator_' . $patient,
				cmd	=> $stage1_cmd,
				modules	=> [$gatk_version]
				);

			$run_id = submit_job(
				jobname		=> 'run_indel_realigner_target_creator_' . $patient,
				shell_command	=> $run_script,
				dependencies	=> $run_id,
				max_time	=> $tool_data->{parameters}->{target_creator}->{time},
				mem		=> $tool_data->{parameters}->{target_creator}->{mem},
				cpus_per_task	=> scalar(@input_bams),
				dry_run		=> $tool_data->{dry_run}
				);

			push @patient_jobs, $run_id;
			push @all_jobs, $run_id;
			}
		else {
			print "\nSkipping RealignerTargetCreator because this has already been completed!\n";
			}

		## IndelRealigner
		my @realign_bams;
		my $stage2_cmd = get_indelrealign_command(
			input		=> $input_string,
			intervals	=> $target_intervals,
			java_mem	=> $tool_data->{parameters}->{realign}->{java_mem},
			tmp_dir		=> $tmp_directory
			);

		$stage2_cmd = "cd $intermediate_directory;\n$stage2_cmd;";

		foreach my $inbam (@input_bams) {
			my $outbam = $inbam; 
			$outbam =~ s/.bam/_realigned.bam/; 
			$stage2_cmd .= "\nmd5sum $outbam > $outbam.md5;";
			push @realign_bams, join('/', $intermediate_directory, $outbam);
			}

		# check if this should be run
		if ( ('N' eq $resume) || ('Y' eq missing_file($realign_bams[-1] . '.md5'))) {
			# record command (in log directory) and then run job
			print "\nSubmitting job for IndelRealigner...";
			$run_script = write_script(
				log_dir	=> $log_directory,
				name	=> 'run_indel_realigner_' . $patient,
				cmd	=> $stage2_cmd,
				modules	=> [$gatk_version]
				);

			$run_id = submit_job(
				jobname		=> 'run_indel_realigner_' . $patient,
				shell_command	=> $run_script,
				dependencies	=> $run_id,
				max_time	=> $tool_data->{parameters}->{realign}->{time},
				mem		=> $tool_data->{parameters}->{realign}->{mem},
				cpus_per_task	=> 1,
				dry_run		=> $tool_data->{dry_run}
				);

			push @patient_jobs, $run_id;
			push @all_jobs, $run_id;
			}
		else {
			print "\nSkipping IndelRealigner because this has already been completed!\n";
			}

		# Looks like these two steps are run per sample?
		foreach my $sample (@samples) {

			print "\nPerforming base recalibration steps for: $sample\n";

			my $type;
			if ($sample =~ m/BC|SK|A/) { $type = 'normal'; } else { $type = 'tumour'; }

			## BaseRecalibrator
			my $bqsr_file = join('/', $intermediate_directory, $sample . '.recal_data.grp');
			my @tmp = grep { /$sample/ } @realign_bams;
			my $realigned_bam = $tmp[0];

			my $stage3_cmd = create_recalibration_table(
				input		=> $realigned_bam,
				output		=> $bqsr_file,
				intervals	=> $tool_data->{intervals_bed},
				java_mem	=> $tool_data->{parameters}->{bqsr}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($bqsr_file)) ) {
				# record command (in log directory) and then run job
				print "\nSubmitting job for BaseRecalibrator...";
				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_base_quality_score_recalibrator_' . $sample,
					cmd	=> $stage3_cmd,
					modules	=> [$gatk_version]
					);

				$run_id2 = submit_job(
					jobname		=> 'run_base_quality_score_recalibrator_' . $sample,
					shell_command	=> $run_script,
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{bqsr}->{time},
					mem		=> $tool_data->{parameters}->{bqsr}->{mem},
					cpus_per_task	=> 8,
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id2;
				push @all_jobs, $run_id2;
				}
			else {
				print "\nSkipping BaseRecalibrator because this has already been completed!\n";
				}

			## PrintReads
			my $recal_bam = join('/', $patient_directory, $sample . '_realigned_recalibrated.bam');

			my $stage4_cmd = create_recalibrated_bam(
				input		=> $realigned_bam,
				bqsr		=> $bqsr_file,
				output		=> $recal_bam,
				java_mem	=> $tool_data->{parameters}->{recalibrate}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($recal_bam . '.md5'))) {
				# record command (in log directory) and then run job
				print "\nSubmitting job for PrintReads (applying base recalibration)...";
				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_apply_base_recalibration_' . $sample,
					cmd	=> $stage4_cmd,
					modules	=> [$gatk_version]
					);

				$run_id2 = submit_job(
					jobname		=> 'run_apply_base_recalibration_' . $sample,
					shell_command	=> $run_script,
					dependencies	=> $run_id2,
					max_time	=> $tool_data->{parameters}->{recalibrate}->{time},
					mem		=> $tool_data->{parameters}->{recalibrate}->{mem},
					cpus_per_task	=> 8,
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id2;
				push @all_jobs, $run_id2;
				}
			else {
				print "\nSkipping PrintReads (apply base recalibration) because this has already been completed!\n";
				}

			push @final_outputs, $recal_bam;

			$cleanup_cmd = "rm $realigned_bam;\nrm ";
			$realigned_bam =~ s/bam/bai/;
			$cleanup_cmd .= $realigned_bam;

			}

		if ('Y' eq $tool_data->{del_intermediate}) {

			$cleanup_cmd .= ";\nrm -rf $tmp_directory";

			$run_script = write_script(
				log_dir	=> $log_directory,
				name	=> 'run_cleanup_' . $patient,
				cmd	=> $cleanup_cmd
				);

			$run_id = submit_job(
				jobname		=> 'run_cleanup_' . $patient,
				shell_command	=> $run_script,
				dependencies	=> join(',', @patient_jobs),
				max_time	=> '00:05:00',
				mem		=> '256M',
				cpus_per_task	=> 1,
				dry_run		=> $tool_data->{dry_run}
				);
			}

		print "\nFINAL OUTPUT:\n" . join("\n  ", @final_outputs) . "\n";
		print "---\n";
		}

	# collect job metrics
	opendir(LOGFILES, $log_directory) or die "Cannot open $log_directory";
	my @files = grep { /slurm_job_metrics/ } readdir(LOGFILES);
	my $count = scalar(@files) + 1;
	closedir(LOGFILES);

	my $outfile = $log_directory . '/slurm_job_metrics_' . $count . '.out';

	my $collect_metrics = collect_job_stats(
		job_ids	=> join(',', @all_jobs),
		outfile	=> $outfile
		);

	$run_script = write_script(
		log_dir	=> $log_directory,
		name	=> 'output_job_metrics',
		cmd	=> $collect_metrics
		);

	$run_id = submit_job(
		jobname		=> 'output_job_metrics',
		shell_command	=> $run_script,
		dependencies	=> join(',', @all_jobs),
		max_time	=> '0:10:00',
		mem		=> '1G',
		cpus_per_task	=> 1,
		dry_run		=> $tool_data->{dry_run}
		);

	# final job to output a BAM config for downstream stuff
	my $output_yaml_cmd = join(' ',
		"perl $cwd/shared/create_bam_yaml.pl",
		'-d', $output_directory,
		'-o', $output_directory . '/bam_config.yaml'
		);

	$run_script = write_script(
		log_dir	=> $log_directory,
		name	=> 'output_final_yaml',
		cmd	=> $output_yaml_cmd,
		modules	=> ['perl']
		);

	$run_id = submit_job(
		jobname		=> 'output_final_yaml',
		shell_command	=> $run_script,
		dependencies	=> join(',', @all_jobs),
		max_time	=> '0:10:00',
		mem		=> '1G',
		cpus_per_tasks	=> 1,
		dry_run		=> $tool_data->{dry_run}
		);

	# finish up
	print "\nProgramming terminated successfully.\n\n";

	}

### GETOPTS PLUS ERROR CHECKING AND DEFAULT VALUES #################################################
# declare variables
my $tool_config;
my $data_config;

# read in command line arguments
GetOptions(
	't|tool=s'	=> \$tool_config,
	'c|config=s'	=> \$data_config
	);

main(tool_config => $tool_config, data_config => $data_config);
