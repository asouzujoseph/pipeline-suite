#!/usr/bin/env perl
### variant_call.pl ################################################################################
use AutoLoader 'AUTOLOAD';
use strict;
use warnings;
use Carp;
use Getopt::Std;
use Getopt::Long;
use POSIX qw(strftime);
use File::Basename;
use File::Path qw(make_path);
use YAML qw(LoadFile);

my $cwd = dirname($0);
require "$cwd/shared/utilities.pl";

####################################################################################################
# version       author		comment
# 1.1		sprokopec       script to run HaplotypeCaller and Oncotator on RNASeq data
# 1.2		sprokopec	updates to move indel realign/recalibration to gatk.pl AND
# 				change oncotator/funcotator to VEP (vcf2maf)

### USAGE ##########################################################################################
# variant_call.pl -t tool_config.yaml -c data_config.yaml
#
# where:
# 	- tool_config.yaml contains tool versions and parameters, output directory,
# 	reference information, etc.
# 	- data_config.yaml contains sample information (YAML file containing paths to BWA- or 
# 	STAR-aligned BAMs (post merge/markdup), generated by create_final_yaml.pl)

### DEFINE SUBROUTINES #############################################################################
# format command to run GATK HaplotypeCaller
sub get_haplotype_command {
	my %args = (
		tumour		=> undef,
		normal		=> undef,
		reference	=> undef,
		output		=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $gatk_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T HaplotypeCaller',
		'-R', $args{reference},
		'-I', $args{tumour},
		'-o', $args{output},
		'-dontUseSoftClippedBases',
		'-stand_call_conf 20.0'
		);

	if (defined($args{normal})) {
		$gatk_command .= ' -I ' . $args{normal};
		}

	return($gatk_command);
	}

# format command to run variant filter
sub get_filter_command {
	my %args = (
		input		=> undef,
		reference	=> undef,
		output		=> undef,
		java_mem	=> undef,
		tmp_dir		=> undef,
		@_
		);

	my $gatk_command = join(' ',
		'java -Xmx' . $args{java_mem},
		'-D' . $args{tmp_dir},
		'-jar $gatk_dir/GenomeAnalysisTK.jar -T VariantFiltration',
		'-R', $args{reference},
		'-V', $args{input},
		'-window 35',
		'-cluster 3',
		'-filterName FS -filter "FS > 30.0"',
		'-filterName QD -filter "QD < 2.0"',
		'-o', $args{output}
		);

	return($gatk_command);
	}

### MAIN ###########################################################################################
sub main{
	my %args = (
		tool_config	=> undef,
		data_config	=> undef,
		data_type	=> undef,
		@_
		);

	my $tool_config = $args{tool_config};
	my $data_config = $args{data_config};
	my $data_type	= $args{data_type};

	### PREAMBLE ######################################################################################

	# load tool config
	my $tool_data_orig = LoadFile($tool_config);
	my $tool_data = error_checking(tool_data => $tool_data_orig, pipeline => 'variant_call', data_type => $data_type);
	$tool_data->{date} = strftime "%F", localtime;
	
	# check for resume and confirm output directories
	my ($resume, $output_directory, $log_directory) = set_output_path(tool_data => $tool_data);

	# start logging
	print "---\n";
	print "Running Variant Call pipeline.\n";
	print "\n  Tool config used: $tool_config";
	print "\n    Reference used: $tool_data->{reference}";
	print "\n    Output directory: $output_directory";
	print "\n  Sample config used: $data_config";
	print "\n---";

	# set tools and versions
	my $samtools = 'samtools/' . $tool_data->{samtools_version};

	# create a file to hold job metrics
	my (@files, $run_count, $outfile, $touch_exit_status);
	if ('N' eq $tool_data->{dry_run}) {
		# initiate a file to hold job metrics (ensures that an existing file isn't overwritten by concurrent jobs)
		opendir(LOGFILES, $log_directory) or die "Cannot open $log_directory";
		@files = grep { /slurm_job_metrics/ } readdir(LOGFILES);
		$run_count = scalar(@files) + 1;
		closedir(LOGFILES);

		$outfile = $log_directory . '/slurm_job_metrics_' . $run_count . '.out';
		$touch_exit_status = system("touch $outfile");
		if (0 != $touch_exit_status) { Carp::croak("Cannot touch file $outfile"); }
		}

	### RUN ###########################################################################################
	# get sample data
	my $smp_data = LoadFile($data_config);

	my ($run_script, $run_id, $link);
	my @all_jobs;

	# process each sample in $smp_data
	foreach my $patient (sort keys %{$smp_data}) {

		print "\nInitiating process for PATIENT: $patient\n";

		my $patient_directory = join('/', $output_directory, $patient);
		unless(-e $patient_directory) { make_path($patient_directory); }

		my $link_directory = join('/', $patient_directory, 'bam_links');
		unless(-e $link_directory) { make_path($link_directory); }

		my @normal_ids = keys %{$smp_data->{$patient}->{'normal'}};
		my $normal = undef;

		# do some case handling
		if (scalar(@normal_ids) > 1) {
			print "  <<Found multiple 'normal' files; using only the first case!>>\n";
			$normal = $normal_ids[0];
			} elsif (scalar(@normal_ids) == 0) {
			print "  <<No 'normal' provided; running variant calling in tumour-only mode.>>\n";
			}

		my @tumour_ids = keys %{$smp_data->{$patient}->{'tumour'}};

		# create some symlinks
		if ($normal) {
			my @tmp = split /\//, $smp_data->{$patient}->{normal}->{$normal};
			$link = join('/', $link_directory, $tmp[-1]);
			symlink($smp_data->{$patient}->{normal}->{$normal}, $link);
			}

		# create an array to hold final outputs and all patient job ids
		my (@final_outputs, @patient_jobs);
		my $cleanup_cmd;

		foreach my $sample (@tumour_ids) {

			print "  TUMOUR: $sample\n";
			if ($normal) { print "  NORMAL: $normal\n"; }
			print "\n";

			my $sample_directory = join('/', $patient_directory, $sample);
			unless(-e $sample_directory) { make_path($sample_directory); }

			my $tmp_directory = join('/', $sample_directory, 'TEMP');
			unless(-e $tmp_directory) { make_path($tmp_directory); }
			$cleanup_cmd = "rm -rf $tmp_directory";

			# create a symlink for the bam
			my @tmp = split /\//, $smp_data->{$patient}->{tumour}->{$sample};
			$link = join('/', $link_directory, $tmp[-1]);
			symlink($smp_data->{$patient}->{tumour}->{$sample}, $link);

			# initiate some sample-specific variables
			$run_id = '';

			# run HaplotypeCaller
			my $gatk = 'gatk/' . $tool_data->{tool_version};
			my $hc_vcf = join('/', $sample_directory, $sample . '_HaplotypeCaller.vcf');
			$cleanup_cmd .= "\nrm $hc_vcf";
			$cleanup_cmd .= "\nrm $hc_vcf.idx";

			my $call_variants_cmd;
			if ($normal) {
				$call_variants_cmd = get_haplotype_command(
					tumour		=> $smp_data->{$patient}->{tumour}->{$sample},
					normal		=> $smp_data->{$patient}->{normal}->{$normal},
					reference	=> $tool_data->{reference},
					output		=> $hc_vcf,
					java_mem	=> $tool_data->{parameters}->{haplotype_call}->{java_mem},
					tmp_dir		=> $tmp_directory
					);
				} else {
				$call_variants_cmd = get_haplotype_command(
					tumour		=> $smp_data->{$patient}->{tumour}->{$sample},
					reference	=> $tool_data->{reference},
					output		=> $hc_vcf,
					java_mem	=> $tool_data->{parameters}->{haplotype_call}->{java_mem},
					tmp_dir		=> $tmp_directory
					);
				}

			$call_variants_cmd .= "\nmd5sum $hc_vcf > $hc_vcf.md5";

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($hc_vcf . '.md5')) ) {

				# record command (in log directory) and then run job
				print "Submitting job for HaplotypeCaller...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_haplotype_caller_' . $sample,
					cmd	=> $call_variants_cmd,
					modules	=> [$gatk],
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{haplotype_call}->{time},
					mem		=> $tool_data->{parameters}->{haplotype_call}->{mem},
					hpc_driver	=> $tool_data->{HPC_driver}
					);

				$run_id = submit_job(
					jobname		=> 'run_haplotype_caller_' . $sample,
					shell_command	=> $run_script,
					hpc_driver	=> $tool_data->{HPC_driver},
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id;
				push @all_jobs, $run_id;
				}
			else {
				print "Skipping HaplotypeCaller because this has already been completed!\n";
				}

			# run filter variants
			my $filtered_vcf = join('/', $sample_directory, $sample . '_HaplotypeCaller_filtered.vcf');
			$cleanup_cmd .= "\nrm $filtered_vcf";
			$cleanup_cmd .= "\nrm $filtered_vcf.idx";

			my $filter_cmd = get_filter_command(
				input		=> $hc_vcf,
				output		=> $filtered_vcf,
				reference	=> $tool_data->{reference},
				java_mem	=> $tool_data->{parameters}->{filter}->{java_mem},
				tmp_dir		=> $tmp_directory
				);

			$filter_cmd .= "\nmd5sum $filtered_vcf > $filtered_vcf.md5";

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($filtered_vcf . '.md5')) ) {

				# record command (in log directory) and then run job
				print "Submitting job for Variant Filtration...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_filter_variants_' . $sample,
					cmd	=> $filter_cmd,
					modules	=> [$gatk],
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{filter}->{time},
					mem		=> $tool_data->{parameters}->{filter}->{mem},
					hpc_driver	=> $tool_data->{HPC_driver}
					);

				$run_id = submit_job(
					jobname		=> 'run_filter_variants_' . $sample,
					shell_command	=> $run_script,
					hpc_driver	=> $tool_data->{HPC_driver},
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id;
				push @all_jobs, $run_id;
				}
			else {
				print "Skipping Variant Filtration because this has already been completed!\n";
				}

			### Run variant annotation (VEP + vcf2maf)
			my $final_vcf = join('/', $sample_directory, $sample . '_HaplotypeCaller_filtered_annotated.vcf');
			my $final_maf = join('/', $sample_directory, $sample . '_HaplotypeCaller_filtered_annotated.maf');

			my $vcf2maf_cmd;
			if ($normal) {
				$vcf2maf_cmd = get_vcf2maf_command(
					input		=> $filtered_vcf,
					tumour_id	=> $sample,
					reference	=> $tool_data->{reference},
					ref_type	=> $tool_data->{ref_type},
					output		=> $final_maf,
					tmp_dir		=> $tmp_directory,
					vcf2maf		=> $tool_data->{parameters}->{annotate}->{vcf2maf_path},
					vep_path	=> $tool_data->{parameters}->{annotate}->{vep_path},
					vep_data	=> $tool_data->{parameters}->{annotate}->{vep_data},
					filter_vcf	=> $tool_data->{parameters}->{annotate}->{filter_vcf}
					);
				} else {
				$vcf2maf_cmd = get_vcf2maf_command(
					input		=> $filtered_vcf,
					tumour_id	=> $sample,
					normal_id	=> $normal,
					reference	=> $tool_data->{reference},
					ref_type	=> $tool_data->{ref_type},
					output		=> $final_maf,
					tmp_dir		=> $tmp_directory,
					vcf2maf		=> $tool_data->{parameters}->{annotate}->{vcf2maf_path},
					vep_path	=> $tool_data->{parameters}->{annotate}->{vep_path},
					vep_data	=> $tool_data->{parameters}->{annotate}->{vep_data},
					filter_vcf	=> $tool_data->{parameters}->{annotate}->{filter_vcf}
					);
				}

			# check if this should be run
			if ( ('N' eq $resume) || ('Y' eq missing_file($final_maf . '.md5')) ) {

				# IF THIS FINAL STEP IS SUCCESSFULLY RUN,
				# create a symlink for the final output in the TOP directory
				my @final = split /\//, $final_maf;
				my $final_link = join('/', $tool_data->{output_dir}, $final[-1]);

				if (-l $final_link) {
					unlink $final_link or die "Failed to remove previous symlink: $final_link";
					}

				$vcf2maf_cmd .= "\n\n" . join("\n",
					"if [ -s " . join(" ] && [ -s ", $final_maf) . " ]; then",
					"md5sum $final_maf > $final_maf.md5",
					"ln -s $final_maf $final_link",
					"mv $tmp_directory/$sample" . "_HaplotypeCaller_filtered.vep.vcf $final_vcf",
					"md5um $final_vcf > $final_vcf.md5",
					"else",
					'echo "FINAL OUTPUT MAF is missing; not running md5sum or producing final symlink..."',
					"fi"
					);

				# record command (in log directory) and then run job
				print "Submitting job for vcf2maf...\n";

				$run_script = write_script(
					log_dir	=> $log_directory,
					name	=> 'run_vcf2maf_and_VEP_' . $sample,
					cmd	=> $vcf2maf_cmd,
					modules	=> ['perl', $samtools],
					dependencies	=> $run_id,
					max_time	=> $tool_data->{parameters}->{annotate}->{time},
					mem		=> $tool_data->{parameters}->{annotate}->{mem},
					hpc_driver	=> $tool_data->{HPC_driver}
					);

				$run_id = submit_job(
					jobname		=> 'run_vcf2maf_and_VEP_' . $sample,
					shell_command	=> $run_script,
					hpc_driver	=> $tool_data->{HPC_driver},
					dry_run		=> $tool_data->{dry_run}
					);

				push @patient_jobs, $run_id;
				push @all_jobs, $run_id;
				}
			else {
				print "Skipping vcf2maf because this has already been completed!\n";
				}

			push @final_outputs, $final_maf;
			}

		# should intermediate files be removed
		# run per patient
		if ('Y' eq $tool_data->{del_intermediate}) {

			print "Submitting job to clean up temporary/intermediate files...\n";

			# make sure final output exists before removing intermediate files!
			$cleanup_cmd = join("\n",
				"if [ -s " . join(" ] && [ -s ", @final_outputs) . " ]; then",
				$cleanup_cmd,
				"else",
				'echo "One or more FINAL OUTPUT FILES is missing; not removing intermediates"',
				"fi"
				);

			$run_script = write_script(
				log_dir	=> $log_directory,
				name	=> 'run_cleanup_' . $patient,
				cmd	=> $cleanup_cmd,
				dependencies	=> join(',', @patient_jobs),
				max_time	=> '00:05:00',
				mem		=> '256M',
				hpc_driver	=> $tool_data->{HPC_driver}
				);

			$run_id = submit_job(
				jobname		=> 'run_cleanup_' . $patient,
				shell_command	=> $run_script,
				hpc_driver	=> $tool_data->{HPC_driver},
				dry_run		=> $tool_data->{dry_run}
				);
			}

		print "\nFINAL OUTPUT:\n" . join("\n  ", @final_outputs) . "\n";
		print "---\n";
		}

	if ('N' eq $tool_data->{dry_run}) {

		# collect job stats
		my $collect_metrics = collect_job_stats(
			job_ids	=> join(',', @all_jobs),
			outfile	=> $outfile
			);

		$run_script = write_script(
			log_dir	=> $log_directory,
			name	=> 'output_job_metrics_' . $run_count,
			cmd	=> $collect_metrics,
			dependencies	=> join(',', @all_jobs),
			max_time	=> '0:10:00',
			mem		=> '1G',
			hpc_driver	=> $tool_data->{HPC_driver}
			);

		$run_id = submit_job(
			jobname		=> 'output_job_metrics',
			shell_command	=> $run_script,
			hpc_driver	=> $tool_data->{HPC_driver},
			dry_run		=> $tool_data->{dry_run}
			);
		}

	# final job to output a BAM config for downstream stuff
	if ('Y' eq $tool_data->{create_output_yaml}) {

		print "Creating config yaml for output VCF and MAF files...\n";

		my $output_yaml_cmd_vcf = join(' ',
			"perl $cwd/shared/create_final_yaml.pl",
			'-d', $output_directory,
			'-o', $output_directory . '/vcf_config.yaml',
			'-p', 'vep.vcf$' 
			);

		my $output_yaml_cmd_maf = join(' ',
			"perl $cwd/shared/create_final_yaml.pl",
			'-d', $output_directory,
			'-o', $output_directory . '/maf_config.yaml',
			'-p', 'annotated.maf$' 
			);

		$run_script = write_script(
			log_dir	=> $log_directory,
			name	=> 'output_final_yaml',
			cmd	=> $output_yaml_cmd_vcf . ";\n" . $output_yaml_cmd_maf,
			modules	=> ['perl'],
			dependencies	=> join(',', @all_jobs),
			max_time	=> '00:10:00',
			mem		=> '1G',
			hpc_driver	=> $tool_data->{HPC_driver}
			);

		$run_id = submit_job(
			jobname		=> 'output_final_yaml',
			shell_command	=> $run_script,
			hpc_driver	=> $tool_data->{HPC_driver},
			dry_run		=> $tool_data->{dry_run}
			);

		} else {
			print "Not creating output config yaml as requested...\n";
		}

	# finish up
	print "\nProgramming terminated successfully.\n\n";

	}

### GETOPTS AND DEFAULT VALUES #####################################################################
# declare variables
my $tool_config;
my $data_config;

# get command line arguments
GetOptions(
	't|tool=s'	=> \$tool_config,
	'c|config=s'	=> \$data_config
	);

# do some quick error checks to confirm valid arguments	
if (!defined($tool_config)) { die("No tool config file defined; please provide -t | --tool (ie, tool_config.yaml)"); }
if (!defined($data_config)) { die("No data config file defined; please provide -c | --config (ie, sample_config.yaml)"); }

main(tool_config => $tool_config, data_config => $data_config);
