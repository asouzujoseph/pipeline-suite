### collect_gatk_cnv_output.R ######################################################################
# Finds and combines output generated by GATK:CNV or GATK:gCNV

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### PREPARE SESSION ################################################################################
# import libraries
library(GenomicRanges);
library(org.Hs.eg.db);
library(argparse);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-r', '--ref_type', type = 'character', help = 'reference type', default = 'hg38');
parser$add_argument('-t', '--targets', type = 'character', help = 'target intervals');
parser$add_argument('-g', '--germline', type = 'logical', help = 'is this germline data?', default = FALSE);

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### FORMAT ANNOTATION ##############################################################################
if (arguments$ref_type %in% c('hg38','GRCh38')) {
	library(TxDb.Hsapiens.UCSC.hg38.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene;
	} else if (arguments$ref_type %in% c('hg19','GRCh37')) {
	library(TxDb.Hsapiens.UCSC.hg19.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene;
	}
 
# organize all transcripts by GeneID
txdb_table <- transcriptsBy(txdb, by = 'gene');

# extract GeneIDs
tx_ids <- names(txdb_table);

# extract 
transcript_table <- select(
	TxDb.Hsapiens.UCSC.hg38.knownGene,
	keys = tx_ids,
	columns = c('GENEID','TXNAME','TXCHROM','TXSTART','TXEND'),
	keytype = 'GENEID'
	);
colnames(transcript_table)[1] <- 'ENTREZID';

# pull in extra annotations
transcript_table$SYMBOL <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'SYMBOL'
	);

transcript_table$ENSEMBL <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'ENSEMBL'
	);

transcript_table$MAP <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'MAP'
	);

transcript_table$GENETYPE <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'GENETYPE'
	);

# remove unmatching cases
transcript_table$MAPCHROM <- sapply(
	transcript_table$MAP,
	function(i) { paste0('chr', unlist(strsplit(i, 'p|q'))[1]) }
	);

transcript_table <- transcript_table[which(transcript_table$TXCHROM == transcript_table$MAPCHROM),];

# squish it to 1 entry per gene
gene.annotation <- merge(
	aggregate(TXSTART ~ ENTREZID + SYMBOL + ENSEMBL + GENETYPE + TXCHROM, transcript_table, min),
	aggregate(TXEND ~ ENTREZID + SYMBOL + ENSEMBL + GENETYPE + TXCHROM, transcript_table, max),
	);
colnames(gene.annotation)[5:7] <- c('Chromosome','Start','End');
gene.annotation$Chromosome <- factor(gene.annotation$Chromosome, levels = paste0('chr',c(1:22,'X','Y')));
gene.annotation <- gene.annotation[order(gene.annotation$Chromosome, gene.annotation$Start),];

gene.gr <- GRanges(gene.annotation);

# if provided, filter to target intervals
gene.annotation$Target <- NA;
if (!is.null(arguments$targets)) {

	target.intervals <- read.delim(arguments$targets, header = FALSE, comment.char = '@');
	colnames(target.intervals)[1:3] <- c('Chromosome','Start','End');

	target.gr <- GRanges(target.intervals);

	overlaps <- as.data.frame(findOverlaps(gene.gr, target.gr));

	gene.annotation$Target <- 0;
	gene.annotation[unique(overlaps$queryHits),]$Target <- 1;
	}

### MAIN ###########################################################################################
if (arguments$germline) {

	# find results files
	ratio.files <- list.files(pattern = 'denoised_copy_ratios.tsv$', recursive = TRUE);
	seg.files <- list.files(pattern = 'genotyped_segments.vcf$', recursive = TRUE);

	# read them in
	ratio.list <- list();

	for (file in ratio.files) {
		# extract sample ID
		smp <- unlist(strsplit(basename(file), '\\_'))[1];
		# store data in list
		tmp <- read.delim(file, as.is = TRUE, comment.char = '@');
		colnames(tmp)[4] <- smp;
		ratio.list[[smp]] <- tmp;
		rm(tmp);
		}

	library(plyr);
	ratio.data <- join_all(ratio.list);

	colnames(ratio.data)[1:3] <- c('chrom','start','end');
	seg.gr <- GRanges(ratio.data);
	y <- mergeByOverlaps(gene.gr, seg.gr, minoverlap = 500, select = 'all');
	tmp <- data.frame(y[['gene.gr']], y[['seg.gr']]);
	colnames(tmp)[1:5] <- paste0('gene.',colnames(tmp)[1:5]);
	colnames(tmp)[10:14] <- paste0('seg.', gsub('\\.1','',colnames(tmp)[10:14]));

	gene.by.patient <- aggregate(
		tmp[,grepl('INS',colnames(tmp))],
		by = list(
			SYMBOL = tmp$SYMBOL,
			ENTREZID = tmp$ENTREZID,
			ENSEMBL = tmp$ENSEMBL
			),
		FUN = mean
		);

	ratio.data.annotated <- merge(
		gene.annotation,
		gene.by.patient,
		all.y = TRUE
		);

	ratio.data.annotated$SYMBOL <- factor(
		ratio.data.annotated$SYMBOL,
		levels = as.character(gene.annotation$SYMBOL)
		);

	write.table(
		ratio.data.annotated[order(ratio.data.annotated$SYMBOL),],
		file = generate.filename(arguments$project, 'gatk_gcnv_ratio_gene_matrix','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	# read them in
	cn.list <- list();

	for (file in seg.files) {
		# extract sample ID
		smp <- unlist(strsplit(basename(file), '\\_'))[1];
		# store data in list
		tmp <- read.delim(file, as.is = TRUE, comment.char = '#', header = FALSE);
		colnames(tmp) <- c('chrom','start','id','ref','alt','qual','filter','info','format','sample');
		tmp$end <- as.numeric(gsub('END=','',tmp$info));
		tmp$QA <- apply(tmp[,c('format','sample')], 1, function(i) {
			idx <- which(unlist(strsplit(i[1],':')) == 'QA');
			quality <- unlist(strsplit(i[2],':'))[idx];
			return(as.numeric(quality));
			} );
		tmp <- tmp[which(tmp$QA >= 20),];
		tmp$CN <- apply(tmp[,c('format','sample')], 1, function(i) {
			idx <- which(unlist(strsplit(i[1],':')) == 'CN');
			cn <- unlist(strsplit(i[2],':'))[idx];
			return(cn);
			} );
		cn.list[[smp]] <- tmp[,c('chrom','start','end','CN')];
		cn.list[[smp]]$ID <- smp;
		rm(tmp);
		}

	cn.data <- do.call(rbind, cn.list);
	cn.data$CN <- as.numeric(cn.data$CN);

	write.table(
		cn.data[,c('ID','chrom','start','end','CN')],
		file = generate.filename(arguments$project, 'gatk_gcnv_perbin_data','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	seg.gr <- GRanges(cn.data);
	y <- mergeByOverlaps(gene.gr, seg.gr, minoverlap = 500, type = 'any', select = 'all', maxgap = -1);
	tmp <- data.frame(y[['gene.gr']], y[['seg.gr']]);
	colnames(tmp)[1:5] <- paste0('gene.',colnames(tmp)[1:5]);
	colnames(tmp)[10:14] <- paste0('seg.', gsub('\\.1','',colnames(tmp)[10:14]));

	pergene.data <- lapply(unique(tmp$ID), function(smp) { 
		x <- aggregate(CN ~ SYMBOL + ENTREZID + ENSEMBL, tmp[which(tmp$ID == smp),], function(i) { max(i)-2 } );
		colnames(x)[4] <- smp;
		return(x);
		});

	gene.by.data <- join_all(pergene.data);

	cn.data.annotated <- merge(
		gene.annotation,
		gene.by.data,
		all.y = TRUE
		);

	cn.data.annotated$SYMBOL <- factor(
		cn.data.annotated$SYMBOL,
		levels = as.character(gene.annotation$SYMBOL)
		);

	write.table(
		cn.data.annotated[order(cn.data.annotated$SYMBOL),],
		file = generate.filename(arguments$project, 'gatk_gcnv_gene_matrix','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	} else {

	# find results files
	cr.files <- list.files(pattern = 'called.seg', recursive = TRUE);

	# read them in
	cn.list <- list();

	for (file in cr.files) {
		# extract sample ID
		smp <- unlist(strsplit(basename(file), '\\.'))[1];
		# store data in list
		tmp <- read.delim(file, as.is = TRUE, comment.char = '@');
		tmp$ID <- smp;
		cn.list[[smp]] <- tmp;
		rm(tmp);
		}

	cn.data <- do.call(rbind, cn.list);

	# adjust slightly for compatibility with cbioportal
	cn.data <- cn.data[,c('ID','CONTIG','START','END','NUM_POINTS_COPY_RATIO','MEAN_LOG2_COPY_RATIO','CALL')];
	colnames(cn.data) <- c('ID','chrom','loc.start','loc.end','num.mark','seg.mean','call');

	# save combined/formatted data to file
	write.table(
		cn.data[,1:6],
		file = generate.filename(arguments$project, 'gatk_cnv_for_gistic', 'tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	cn.data$chrom <- gsub('chr','',cn.data$chrom);
	write.table(
		cn.data,
		file = generate.filename(arguments$project, 'gatk_cnv_for_cbioportal', 'seg'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	# define a results table
	gene.data.cn <- gene.annotation;
	gene.data.cn[,names(cn.list)] <- 0;
	gene.data.ratio <- gene.data.cn;

	pga.values <- list();

	for (smp in names(cn.list)) {

		# convert to GRanges
		tmp <- cn.list[[smp]][,c('CONTIG','START','END','MEAN_LOG2_COPY_RATIO','CALL')];
		colnames(tmp) <- c('chrom','start','end','RATIO','CN');
		tmp$CN <- factor(tmp$CN, levels = c('-','0','+'), labels = c(-1,0,1));
		tmp$CN <- as.numeric(as.character(tmp$CN));

		if (nrow(tmp) == 0) { next; }
		rownames(tmp) <- paste0('seg', 1:nrow(tmp));

		# calculate PGA
		for.pga <- tmp[which(tmp$CN != 0),];
		pga <- sum(for.pga$end - for.pga$start)/(3*10**9)*100;
		pga.values[[smp]] <- pga;

		# extract gene data
		seg.gr <- GRanges(tmp);

		# find overlap with genes (any amount of overlap)
		overlapGenes <- as.data.frame(findOverlaps(seg.gr, gene.gr, minoverlap = 20));
		regionsWithHits <- as.data.frame(seg.gr[unique(overlapGenes$queryHits)]);

		for (i in rownames(regionsWithHits)) {
			genes <- gene.gr[overlapGenes[which(overlapGenes$queryHits == sub('seg','',i)),]$subjectHits,]$SYMBOL;
			gene.data.cn[which(gene.data.cn$SYMBOL %in% genes),smp] <- tmp[i,]$CN;
			gene.data.ratio[which(gene.data.ratio$SYMBOL %in% genes),smp] <- tmp[i,]$RATIO;
			}
		}

	pga.data <- do.call(rbind, pga.values);
	colnames(pga.data)[1] <- 'PGA';

	# save data to file
	write.table(
		pga.data,
		file = generate.filename(arguments$project, 'gatk_pga_estimates','tsv'),
		row.names = TRUE,
		col.names = TRUE,
		sep = '\t'
		);

	write.table(
		gene.data.cn,
		file = generate.filename(arguments$project, 'gatk_cna_gene_matrix', 'tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	write.table(
		gene.data.ratio,
		file = generate.filename(arguments$project, 'gatk_ratio_gene_matrix', 'tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('CollectCNVs','SessionProfile','txt'));
