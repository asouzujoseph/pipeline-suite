### collect_sequenza_output.R ######################################################################
# Finds and combines output generated by Sequenza (CN segments, cellularity, ploidy)

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

# function to fill gaps (provided by jbruce)
fillgaps <- function(seg) {
  
	for (i in 1:(nrow(seg)-1)) {

		chr <- as.character(seg[i,]$chromos);
		start <- seg[i,]$start.pos;
		end <- seg[i,]$end.pos;

		if (seg[i+1,"chromosome"] == chr & seg[i+1,"start.pos"] != (end + 1)) {

      			if (abs(seg[i,"CNt"]) > abs(seg[i+1,"CNt"])) {
				seg[i,"end.pos"] <- seg[i+1,"start.pos"]-1;
				} else {
				seg[i+1,"start.pos"] <- seg[i,"end.pos"]+1;
				}
			}
		}

	return(seg);
	}

### PREPARE SESSION ################################################################################
# import libraries
library(GenomicRanges);
library(argparse);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-g', '--gtf', type = 'character', help = 'annotation gtf (refGene)',
	default = '/cluster/projects/pughlab/references/gencode/GRCh38/gencode.v31.annotation.gtf');
parser$add_argument('-t', '--targets', type = 'character', help = 'target intervals');

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### FORMAT ANNOTATION
# using refGene, indicate genes to keep (coding genes) for gene x patient matrix
refGene <- read.delim(arguments$gtf, header = F, comment.char = '#');

refGene <- droplevels(refGene[which(refGene$V3 == 'gene'),c(1,4,5,9)]);
refGene <- droplevels(refGene[which(refGene$V1 != 'chrM'),]);
colnames(refGene) <- c('Chromosome','Start','End','INFO');

refGene <- refGene[grepl('gene_type protein_coding', refGene$INFO),];
refGene <- refGene[!grepl('tag PAR', refGene$INFO),];

gene.widths <- refGene$End - refGene$Start;
refGene <- droplevels(refGene[which(gene.widths > 20),]);

refGene.gr <- GRanges(refGene);

refGene$GeneID <- sapply(
        refGene$INFO,
        function(i) {
                parts <- unlist(strsplit(as.character(i), ';'));
                gene_name <- unlist(strsplit(parts[grepl('gene_id', parts)], ' '));
                gene_id  <- gene_name[length(gene_name)];
                return(gene_id);
                }
        );

refGene$Symbol <- sapply(
        refGene$INFO,
        function(i) {
                parts <- unlist(strsplit(as.character(i), ';'));
                gene_name <- unlist(strsplit(parts[grepl('gene_name', parts)], ' '));
                gene_symbol <- gene_name[length(gene_name)];
                return(gene_symbol);
                }
        );

refGene$Chromosome <- factor(refGene$Chromosome, levels = paste0('chr',c(1:22,'X','Y')));
refGene <- refGene[,-4];

gene.gr <- GRanges(refGene);

# if provided, filter to target intervals
refGene$Target <- NA;
if (!is.null(arguments$targets)) {

	target.intervals <- read.delim(arguments$targets, header = F, comment.char = '@');
	colnames(target.intervals)[1:4] <- c('Chromosome','Start','End','Strand');

	target.gr <- GRanges(target.intervals);

	overlaps <- as.data.frame(findOverlaps(refGene.gr, target.gr));

	refGene$Target <- 0;
	refGene[unique(overlaps$queryHits),]$Target <- 1;
	}

### MAIN ###########################################################################################
# find results files
cr.files <- list.files(pattern = 'called.seg', recursive = TRUE);
cr.files <- cr.files[!grepl('^2021', cr.files)];

# read them in
cn.list <- list();

for (file in cr.files) {
	# extract sample ID
	smp <- unlist(strsplit(basename(file), '\\.'))[1];
	# store data in list
	tmp <- read.delim(file, as.is = TRUE, comment.char = '@');
	tmp$ID <- smp;
	cn.list[[smp]] <- tmp;
	rm(tmp);
	}

cn.data <- do.call(rbind, cn.list);

# adjust slightly for compatibility with cbioportal
cn.data <- cn.data[,c('ID','CONTIG','START','END','NUM_POINTS_COPY_RATIO','MEAN_LOG2_COPY_RATIO','CALL')];
colnames(cn.data) <- c('ID','chrom','loc.start','loc.end','num.mark','seg.mean','call');

cn.data$chrom <- gsub('chr','',cn.data$chrom);

# save combined/formatted data to file
write.table(
	cn.data,
	file = generate.filename(arguments$project, 'gatk_cnv_calls', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	quote = FALSE,
	sep = '\t'
	);

# define a results table
gene.data <- refGene;
for (smp in names(cn.list)) {
	gene.data[,smp] <- 0;
	}

pga.values <- list();

for (smp in names(cn.list)) {

	# convert to GRanges
	tmp <- cn.list[[smp]][,c('CONTIG','START','END','CALL')];
	colnames(tmp) <- c('chrom','start','end','CN');
	tmp$CN <- factor(tmp$CN, levels = c('-','0','+'), labels = c(-1,0,1));
	tmp$CN <- as.numeric(as.character(tmp$CN));

	tmp <- tmp[which(tmp$CN != 0),];
	if (nrow(tmp) == 0) { next; }
	rownames(tmp) <- paste0('seg', 1:nrow(tmp));

	# calculate PGA
	pga <- sum(tmp$end - tmp$start)/(3*10**9)*100;
	pga.values[[smp]] <- pga;

	# extract gene data
	gr <- GRanges(tmp);

	# find overlap with genes (any amount of overlap)
	overlapGenes <- as.data.frame(findOverlaps(gr, gene.gr, minoverlap = 20));
	regionsWithHits <- as.data.frame(gr[unique(overlapGenes$queryHits)]);

	for (i in rownames(regionsWithHits)) {
		genes <- gene.gr[overlapGenes[which(overlapGenes$queryHits == sub('seg','',i)),]$subjectHits,]$GeneID;
		gene.data[which(gene.data$GeneID %in% genes),smp] <- tmp[i,]$CN;
		}
	}

pga.data <- do.call(rbind, pga.values);
colnames(pga.data)[1] <- 'PGA';

# save data to file
write.table(
	pga.data,
	file = generate.filename(arguments$project, 'gatk_pga_estimates','tsv'),
	row.names = TRUE,
	col.names = TRUE,
	sep = '\t'
	);

write.table(
	gene.data,
	file = generate.filename(arguments$project, 'gatk_cna_gene_matrix', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

rownames(gene.data) <- 1:nrow(gene.data);

# remove untargeted regions
if (is.null(arguments$targets)) {
	gene.data$Target <- 1;
	#gene.data <- gene.data[,-which(colnames(gene.data) == 'Target')];
#	} else { gene.data <- droplevels(gene.data[which(gene.data$Target == 1),]);
	}

# clean up any duplicates (2 or more gene entries with the same symbol that occur adjacent to each other)
dup.idx <- gene.data$Symbol[which(duplicated(gene.data$Symbol))];

for (gene in dup.idx) {

	tmp <- gene.data[which(gene.data$Symbol == gene),];
	if (nrow(tmp) < 2) { next; }

	keep.all <- FALSE;
	for (i in 2:nrow(tmp)) {
		# if all entries have identical CN calls
		if (tmp[i,]$Chromosome == tmp[i-1,]$Chromosome && all(tmp[i,7:ncol(tmp)] == tmp[i-1,7:ncol(tmp)])) {
			keep.all <- TRUE;
			}
		}

	# if they are all the same
	if (keep.all) {
		new.entry <- tmp[1,];
		new.entry$End <- max(tmp$End);
		new.entry$GeneID <- paste(tmp$GeneID, collapse = ';');
		new.entry$Target <- max(tmp$Target);
	
	} else if (any(tmp$Target == 1)) {
		new.entry <- tmp[which(tmp$Target == 1),][1,];
		} else {
		new.entry <- tmp[1,];
		}

	gene.data <- gene.data[-which(gene.data$Symbol == gene),];
	gene.data <- rbind(gene.data, new.entry);
	}

gene.data <- gene.data[order(gene.data$Chromosome, gene.data$Start, gene.data$End),];
colnames(gene.data)[which(colnames(gene.data) == 'Symbol')] <- 'Hugo_Symbol';

write.table(
	gene.data[,c('Hugo_Symbol', names(cn.list))],
	file = generate.filename(arguments$project, 'somatic_cnv_for_cbioportal', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	quote = FALSE,
	sep = '\t'
	);

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('CollectCNAs','SessionProfile','txt'));
