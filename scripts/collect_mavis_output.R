### collect_mavis_output.R #########################################################################
# Finds and combines output generated by MAVIS.

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

# function to annotate entrez gene ids by symbol
annotate.by.symbol <- function(hugo_symbols) {
	mapIds(org.Hs.eg.db,
		keys = hugo_symbols,
		column = "ENTREZID",
		keytype = "SYMBOL",
		multiVals = "first"
		);
	}

### PREPARE SESSION ################################################################################
# import libraries
library(GenomicRanges);
library(argparse);
library(plyr);
library(AnnotationDbi);
library(org.Hs.eg.db);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-t', '--targets', type = 'character', help = 'path to target regions', default = NULL);
parser$add_argument('-g', '--genome', type = 'character', help = 'genome build', default = 'GRCh38');
parser$add_argument('-c', '--center', type = 'character', help = 'data center (for cbioportal annotation)', default = 'PMCC');
parser$add_argument('-f', '--find_drawings', type = 'logical', help = 'find and extract key drawings?', default = FALSE);

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### COLLECT KEY DRAWINGS ###########################################################################
if (arguments$find_drawings) {

	# move to input directory (should be patient directory)
	input.dir <- getwd();
	output.dir <- paste0(input.dir, '/key_drawings');

	# create new folder
	dir.create(output.dir);

	# read in final mavis calls
	mavis.files <- list.files(pattern = 'mavis_summary_all', recursive = TRUE);
	mavis.data <- read.delim(mavis.files[1]);

	keep.figures <- unique(mavis.data$annotation_figure);
	keep.figures <- keep.figures[!grepl('None', keep.figures)];

	# find all svg files
	all.drawings <- list.files(path = input.dir, pattern = '.svg$', recursive = TRUE, full.names = TRUE);

	print(paste('Found', length(all.drawings), 'svg files.'));

	# subset to only final mavis calls
	key.drawings <- intersect(keep.figures, all.drawings);

	print(paste('Found', length(key.drawings), 'svg files also in final MAVIS callset.'));

	# filter drawings (remove any intergenic ones)
	key.drawings <- key.drawings[!grepl('-NA_|_NA.svg', key.drawings)];

	print(paste('  Copying', length(key.drawings), 'gene-gene .svg files to', output.dir, '...'));

	setwd(output.dir);

	for (i in key.drawings) {
		cp.cmd <- paste0('cp ', i, ' .');
		system(cp.cmd);
		}

	write(
		'Copying of gene-gene drawings completed successfully.',
		file = 'find_drawings.COMPLETE'
		);

	} else {

### MAIN ###########################################################################################
	# find results files
	mavis.files <- list.files(pattern = 'mavis_summary_all', recursive = TRUE);

	# read them in
	sv.list <- list();

	for (file in mavis.files) {
		# extract sample ID
		smp <- unlist(strsplit(file, '\\/'))[1];
		# read in and store data in list
		sv.list[[smp]] <- read.delim(file, as.is = TRUE);
		}

	# reshape/format data
	sv.data.full <- join_all(
		sv.list,
		type = 'full',
		match = 'first'
		);
	colnames(sv.data.full)[which(colnames(sv.data.full) == 'X.tracking_id')] <- 'tracking_id';

	key.fields <- c('event_type','gene1_aliases','gene2_aliases','transcript1','transcript2','gene1_direction','gene2_direction','exon_last_5prime','exon_first_3prime','fusion_splicing_pattern','break1_chromosome','break1_position_start','break1_position_end','break2_chromosome','break2_position_start','break2_position_end','break1_split_reads','break2_split_reads','spanning_reads','flanking_pairs','linking_split_reads','library','tracking_id','tools','protocol');

	smp.fields <- sort(colnames(sv.data.full)[grep('_genome|_transcriptome',colnames(sv.data.full))]);
	smp.fields.names <- sapply(smp.fields, function(i) { unlist(strsplit(i,'_'))[1] } );
	normal.smps <- gsub('\\.','-',smp.fields.names[grepl('normal', smp.fields)]);
	tumour.smps <- gsub('\\.','-',smp.fields.names[grepl('diseased_genome', smp.fields)]);
	rna.smps <- gsub('\\.','-',smp.fields.names[grepl('transcriptome', smp.fields)]);

	sv.data <- sv.data.full[,c(key.fields, smp.fields)];

	# fill in missing tools (custom conversion scripts)
	new.tools <- apply(
		sv.data[,c('tracking_id','tools')],
		1,
		function(i) {

			ids <- unlist(strsplit(as.character(i[1]),';'));
			tools <- setdiff(unlist(strsplit(as.character(i[2]),';')),'');

			if (any(grepl('pindel', ids))) { tools <- c(tools,'pindel'); }
			if (any(grepl('svict', ids))) { tools <- c(tools,'svict'); }
			if (any(grepl('novobreak', ids))) { tools <- c(tools,'novobreak'); }
			if (any(grepl('fusioncatcher', ids))) { tools <- c(tools,'fusioncatcher'); }

			toolset <- paste(tools, collapse = ';');
			if (length(tools) > 0) { 
				return(toolset);
				} else {
				return('');
				}
			}
		);

	sv.data$tools <- new.tools;
	sv.data$Fusion <- paste0(sv.data$gene1_aliases,'--',sv.data$gene2_aliases);

	# save combined/formatted data to file
	write.table(
		sv.data,
		file = generate.filename(arguments$project, 'mavis_output','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	# if target regions were provided
	if (!is.null(arguments$targets)) {

		# get target regions
		target_bed <- read.delim(arguments$targets, header = FALSE, comment.char = '#');
		colnames(target_bed)[1:3] <- c('Chromosome','Start','End');

		# create genomic ranges object for target regions
		target.gr <- makeGRangesFromDataFrame(target_bed, starts.in.df.are.0based = TRUE);

		# create genomic ranges object for each breakpoint
		first_bp <- data.frame(
			Chromosome = paste0('chr',sv.data$break1_chromosome),
			Start = sv.data$break1_position_start,
			End = sv.data$break1_position_end
			);

		second_bp <- data.frame(
			Chromosome = paste0('chr',sv.data$break2_chromosome),
			Start = sv.data$break2_position_start,
			End = sv.data$break2_position_end
			);

		bp1.gr <- makeGRangesFromDataFrame(first_bp, starts.in.df.are.0based = FALSE);
		bp2.gr <- makeGRangesFromDataFrame(second_bp, starts.in.df.are.0based = FALSE);

		# find overlaps
		overlaps.p1 <- as.data.frame(findOverlaps(bp1.gr, target.gr));
		overlaps.p2 <- as.data.frame(findOverlaps(bp2.gr, target.gr));

		overlap.data <- merge(
			overlaps.p1,
			overlaps.p2,
			by = 'queryHits',
			suffixes = c('.1','.2'),
			all = TRUE
			);

		# only keep entries for which both breakpoints are within target regions
		to.remove <- which(is.na(overlap.data$subjectHits.1) | is.na(overlap.data$subjectHits.2));
		keep.idx <- unique(overlap.data[-to.remove,]$queryHits);

		# filter initial input
		sv.data.filtered <- sv.data[keep.idx,];

		# save filtered data
		write.table(
			sv.data.filtered,
			file = generate.filename(arguments$project, 'mavis_output_filtered','tsv'),
			row.names = FALSE,
			col.names = TRUE,
			sep = '\t'
			);

		} else { 
		sv.data.filtered <- sv.data;
		}

	### CBIOPORTAL ######################
	tmp <- sv.data.filtered;

	# sort by evidence
	tmp$N.tools <- sapply(tmp$tools, function(i) { length(unlist(strsplit(i,';'))) } );
	tmp$Evidence <- apply(tmp[,grep('reads|pairs', colnames(tmp))],1, function(i) { 
		sum(sapply(i[which(i != 'None')],function(y) { max(as.numeric(unlist(strsplit(as.character(y),';')))) } ))
		} );

	tmp <- tmp[order(tmp$library, tmp$tracking_id, -tmp$N.tools, -tmp$Evidence),];

	# is this a tumour or normal sample?
	tmp$Status <- 'somatic';
	if ( (length(normal.smps) > 0) & (any(tmp$library %in% normal.smps)) ) {
		tmp[which(tmp$library %in% normal.smps),]$Status <- 'germline';
		germ.idx <- which(apply(
			tmp[,names(normal.smps)],1,function(i) { any(i == 'germline', na.rm = TRUE) } ));
		tmp[germ.idx,]$Status <- 'germline';
		}

	# get type of evidence (DNA or RNA)
	tmp[,c('DNA_Support','RNA_Support')] <- 'no';
	tmp[which(tmp$protocol == 'genome'),]$DNA_Support <- 'yes';

	if (length(rna.smps) > 0) {
		tmp[which(tmp$protocol == 'transcriptome'),]$RNA_Support <- 'yes';
		rna.idx <- which(apply(
			tmp[,names(rna.smps)],1,function(i) { any(i == 'expressed', na.rm = TRUE) } ));
		tmp[rna.idx,]$RNA_Support <- 'yes';
		dna.idx <- which(apply(
			tmp[,names(tumour.smps)],1,function(i) { any(i == 'genomic support', na.rm = TRUE) } ));
		tmp[dna.idx,]$DNA_Support <- 'yes';
		}

	# is this an inframe or frameshift variant?
	tmp$Frame <- 'unknown';
	if (any(tmp$fusion_splicing_pattern == 'normal')) {
		tmp[which(tmp$fusion_splicing_pattern == 'normal'),]$Frame <- 'inframe';
		}
	if (any(!tmp$fusion_splicing_pattern %in% c('normal','None'))) {
		tmp[which(!tmp$fusion_splicing_pattern %in% c('normal','None')),]$Frame <- 'frameshift';
		}

	### RECURRENCE FILTER ##############################################################################
	# add quick recurrence filter (likely false positives/artefacts)
	if (length(normal.smps) > 0) {
		germline.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type + Status,
			tmp[which(tmp$library %in% normal.smps),],
			length
			);
		colnames(germline.recurrence)[ncol(germline.recurrence)] <- 'NormalCount';

		recurrence.data <- germline.recurrence;
		}

	if (length(tumour.smps) > 0) {
		somatic.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type + Status,
			tmp[which(tmp$library %in% tumour.smps),],
			length
			);
		colnames(somatic.recurrence)[ncol(somatic.recurrence)] <- 'TumourCount';

		if (exists('recurrence.data')) {
			recurrence.data <- merge(germline.recurrence,somatic.recurrence,all = TRUE);
			} else {
			recurrence.data <- somatic.recurrence;
			}
		}

	if (length(rna.smps) > 0) {
		rna.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type + Status,
			tmp[which(tmp$library %in% rna.smps),],
			length
			);
		colnames(rna.recurrence)[ncol(rna.recurrence)] <- 'RNACount';

		if (exists('recurrence.data')) {
			recurrence.data <- merge(recurrence.data, rna.recurrence, all = TRUE);
			} else {
			recurrence.data <- rna.recurrence;
			}
		}

	# define thresholds
	germline.threshold <- length(normal.smps)*0.9;
	somatic.threshold <- length(tumour.smps)*0.9;
	rna.threshold <- length(rna.smps)*0.9;

	tmp2 <- merge(tmp, recurrence.data, all.x = TRUE);
	to.remove <- c(
		which(tmp2$Status == 'germline' & tmp2$NormalCount > germline.threshold),
		which(tmp2$Status == 'somatic' & tmp2$TumourCount > somatic.threshold),
		which(tmp2$protocol == 'transcriptome' & tmp2$RNACount > rna.threshold)
		);

	print(paste0('Removing ', length(to.remove), ' (', round(length(to.remove)/nrow(tmp)*100),
		'%) SVs for high breakpoint recurrence.'));

	if (length(to.remove) > 0) {
		filtered.svs <- tmp2[-to.remove,colnames(tmp)];
		} else {
		filtered.svs <- tmp2[,colnames(tmp)];
		}

	### SIZE FILTER ####################################################################################
	# remove short INDELs (< 100bp)
	filtered.svs$Length <- abs(filtered.svs$break2_position_start - filtered.svs$break1_position_start);
	inter.chrom <- which(filtered.svs$break1_chromosome != filtered.svs$break2_chromosome);
	if (length(inter.chrom) > 0) { filtered.svs[inter.chrom,]$Length <- NA; }

	indel.idx <- which(
		filtered.svs$event_type %in% c('deletion','insertion','duplication') &
		filtered.svs$Length < 100
		);

	if (length(indel.idx) > 0) {
		print(paste0('Removing ', length(indel.idx), ' (', round(length(indel.idx)/nrow(filtered.svs)*100),
			'%) short DEL/INS/DUP (<100bp).'));
		filtered.svs <- filtered.svs[-c(indel.idx),];
		}

	# format for cBioportal
	cbio.svs <- data.frame(
		Sample_ID = filtered.svs$library,
		Site1_Hugo_Symbol = filtered.svs$gene1_aliases,
		Site1_Entrez_Gene_Id = annotate.by.symbol(filtered.svs$gene1_aliases),
		Site1_Ensembl_Transcript_Id = filtered.svs$transcript1,
		Site1_Exon = filtered.svs$exon_last_5prime,
		Site1_Chromosome = filtered.svs$break1_chromosome,
		Site1_Position = filtered.svs$break1_position_start,
		Site1_Description = NA,
		Site2_Hugo_Symbol = filtered.svs$gene2_aliases,
		Site2_Entrez_Gene_Id = annotate.by.symbol(filtered.svs$gene2_aliases),
		Site2_Ensembl_Transcript_Id = filtered.svs$transcript2,
		Site2_Exon = filtered.svs$exon_first_3prime,
		Site2_Chromosome = filtered.svs$break2_chromosome,
		Site2_Position = filtered.svs$break2_position_start,
		Site2_Description = NA,
		Site2_Effect_On_Frame = c('INFRAME','FRAMESHIFT','FRAMESHIFT','NONE')[match(
			filtered.svs$fusion_splicing_pattern,c('normal','retained intron','skipped exon','None'))],
		NCBI_Build = rep(arguments$genome,nrow(filtered.svs)),
		DNA_support = filtered.svs$DNA_Support,
		RNA_support = filtered.svs$RNA_Support,
		Normal_Read_Count = NA,
		Tumor_Read_Count = NA,
		Normal_Variant_Count = NA,
		Tumor_Variant_Count = NA,
		Normal_Paired_End_Read_Count = NA,
		Tumor_Paired_End_Read_Count = NA,
		Normal_Split_Read_Count = NA,
		Tumor_Split_Read_Count = NA,
		Annotation = NA,
		Breakpoint_Type = NA,
		Connection_Type = paste0(filtered.svs$gene1_direction,'to',filtered.svs$gene2_direction),
		Event_Info = NA, 
		Class = toupper(filtered.svs$event_type),
		Length = filtered.svs$Length,
		Comments = NA,
		Fusion = paste0(filtered.svs$gene1_aliases, '--', filtered.svs$gene2_aliases),
		Site1_Split_Read_Count = filtered.svs$break1_split_reads,
		Site2_Split_Read_Count = filtered.svs$break2_split_reads,
		Linking_Split_Reads = filtered.svs$linking_split_reads,
		Spanning_Reads = filtered.svs$spanning_reads,
		Flanking_Read_Pairs = filtered.svs$flanking_pairs,
		Tools = filtered.svs$tools,
		Total_Evidence = filtered.svs$Evidence,
		Status = filtered.svs$Status
		);

	# clean up connection type
	cbio.svs$Connection_Type <- factor(cbio.svs$Connection_Type,
		levels = c('5to3','3to5','5to5','3to3')
		);

	# clean up Frame status
	cbio.svs$Site2_Effect_On_Frame <- factor(cbio.svs$Site2_Effect_On_Frame,
		levels = c('INFRAME','FRAMESHIFT')
		);

	to.remove <- unique(c(
		which(cbio.svs$Status == 'germline'),
		which( grepl('None', cbio.svs$Fusion) ),
		which( !grepl(';', cbio.svs$Tools) & cbio.svs$Total_Evidence < 20)
		));

	for.cbio <- cbio.svs[-to.remove,1:35];

	# save to file
	write.table(
		for.cbio,
		file = generate.filename(arguments$project, 'sv_data_for_cbioportal','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	write.table(
		cbio.svs,
		file = generate.filename(arguments$project, 'sv_data_formatted','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	gc();

	### OLD VERSION ###
	# format for cbioportal (fusion_data.txt > DEPRECATED in cbioportal)
	fusion.data <- data.frame(
		Hugo_Symbol = c(
			as.character(for.cbio$Site1_Hugo_Symbol),
			as.character(for.cbio$Site2_Hugo_Symbol)
			),
		Entrez_Gene_Id = c(
			as.character(for.cbio$Site1_Entrez_Gene_Id), 
			as.character(for.cbio$Site2_Entrez_Gene_Id)
			),
		Center = rep(arguments$center, nrow(for.cbio)*2),
		Tumor_Sample_Barcode = rep(for.cbio$Sample_ID, times = 2),
		Fusion = rep(for.cbio$Fusion, times = 2),
		DNA_support = rep(for.cbio$DNA_support, times = 2),
		RNA_support = rep(for.cbio$RNA_support, times = 2),
		Method = rep(gsub(';', ',', cbio.svs[-to.remove,]$Tools), times = 2),
		Frame = tolower(rep(for.cbio$Site2_Effect_On_Frame, times = 2)),
		Fusion_Status = rep(for.cbio$Comments, times = 2)
		);

	fusion.data <- fusion.data[order(fusion.data$Tumor_Sample_Barcode, fusion.data$Fusion, fusion.data$Method, fusion.data$Frame, na.last = FALSE),];
	fusion.data <- fusion.data[!duplicated(fusion.data[,1:5]),];

	# save to file
	write.table(
		fusion.data,
		file = generate.filename(arguments$project, 'fusion_data_for_cbioportal','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	### SAVE SESSION INFO ##############################################################################
	save.session.profile(generate.filename('CollectMAVIS','SessionProfile','txt'));
	}
