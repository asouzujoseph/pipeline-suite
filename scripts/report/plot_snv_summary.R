### plot_snv_summary.R ############################################################################
# Identify and plot recurrent SNVs.
# INPUT:
#	- mutation calls (either single tool or ensemble output by format_ensemble_mutations.R)
#	- callable bases (output by count_callable_bases.R) 

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### PREPARE SESSION ################################################################################
# import libraries
library(xtable);
library(BoutrosLab.plotting.general);
library(argparse);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-p', '--project', type = 'character', help = 'PROJECT name');
parser$add_argument('-o', '--output', type = 'character', help = 'path to output directory');
parser$add_argument('-t', '--seq_type', type = 'character', help = 'exome or wgs', default = 'exome');
parser$add_argument('-i', '--input', type = 'character', help = 'mutation calls in MAF format');
parser$add_argument('-c', '--callable', type = 'character', help = 'path to callable bases file (generated by count_callable_bases.R)');
parser$add_argument('-m', '--msi', type = 'character', help = 'path to msi file (generated by collect_msi_estimates.R)');
parser$add_argument('-s', '--mutsig', type = 'character', help = 'path to mutsig output (*.sig_genes.txt)');

arguments <- parser$parse_args();

### VARIANT CODING
# 1 = missense, 2 = stop gain, 3 = stop loss, 4 = splicing, 5 = frameshift, 6 = in frame indel, 7 = tss
# 8 = RNA, 9 = other (up/downstream, UTR, intergenic, silent, intron), 10 = ITD
variant.codes <- data.frame(
	Classification = c("3'Flank", "5'Flank", "Intron", "RNA", "IGR", "3'UTR", "5'UTR", "Silent",
		"Missense_Mutation", "Splice_Region", "Splice_Site", "In_Frame_Del", "In_Frame_Ins",
		"Frame_Shift_Del", "Frame_Shift_Ins", "Nonsense_Mutation", "Nonstop_Mutation",
		"Translation_Start_Site", "ITD"),
	Group = c('other','other','other','RNA','other','other','other','other','missense',
		'splice_site','splice_site','in_frame_indel','in_frame_indel','frameshift_indel',
		'frameshirt_indel', 'nonsense', 'nonstop', 'tss', 'itd'),
	Code = c(9, 9, 9, 8, 9, 9, 9, 9, 1, 4, 4, 6, 6, 5, 5, 2, 3, 7, 10)
	);

variant.colours <- c('darkseagreen4','darkorchid4','#9AA3F2','yellow','darkorange3','#F9B38E','turquoise1','plum','grey50')
names(variant.colours) <- c('missense','nonsense','nonstop','splicing','frameshift_indel','in_frame_indel','tss','RNA','other');

# for these plots, we will ignore some variant types
variant.colours <- variant.colours[c(1:6,9)];
basechange.colours <- default.colours(8,'pastel')[-5];

# read in list of known driver genes (Cancer Gene Census from COSMIC)
if (exists('/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv')) {
	driver.genes <- read.delim(
		'/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv',
		comment.char = '#'
		);

	driver.genes <- driver.genes[which(driver.genes$Hallmark == 'Yes'),];
	}

### READ DATA ######################################################################################
# get data
input.data <- read.delim(
	arguments$input,
	stringsAsFactors = FALSE
	);

if (is.null(arguments$callable)) {
	callable.bases <- NULL; } else {
	callable.bases <- read.delim(arguments$callable, row.names = 1);
	}

if (is.null(arguments$msi)) {
	msi <- NULL; } else {
	msi <- read.delim(arguments$msi, row.names = 1);
	}

if (is.null(arguments$mutsig)) {
	mutsig <- NULL; } else {
	mutsig <- read.delim(arguments$mutsig, row.names = 1);
	}

# collect list of all samples
all.samples <- sort(as.character(unique(input.data$Tumor_Sample_Barcode)));
alt.sample.names <- all.samples;

# ensure sample names match
if (!is.null(callable.bases)) {
	if (!any(all.samples %in% rownames(callable.bases))) {
		if ( (any(grepl('-', all.samples))) & (!any(grepl('-', rownames(callable.bases)))) ) {
			alt.sample.names <- gsub('-', '.', all.samples);
			}
		if ( (any(grepl("^[[:digit:]]", all.samples))) & (any(grepl('^X',rownames(callable.bases)))) ) {
			alt.sample.names <- paste0('X', alt.sample.names);
			}
		if (!any(alt.sample.names %in% rownames(callable.bases))) {
			stop('Correlation sample names do not match names from other tables');
			}
		callable.bases <- callable.bases[alt.sample.names,];
		callable.bases$Sample <- rownames(callable.bases);
		rownames(callable.bases) <- all.samples;
		} else {
		callable.bases <- callable.bases[all.samples,];
		}
	}

# move to output directory
setwd(arguments$output);

### FORMAT DATA ####################################################################################
# indicate key fields
keep.fields <- c('Tumor_Sample_Barcode','Hugo_Symbol','Chromosome','Variant_Classification','Reference_Allele','Tumor_Seq_Allele2');

print(paste0("Total variants: ", nrow(input.data), " among ", length(all.samples), " samples."));

# add quick recurrence filter (likely false positives/artefacts)
recurrence.data <- aggregate(
	Tumor_Sample_Barcode ~ Chromosome + Start_Position + End_Position + Allele,
	input.data,
	length
	);
colnames(recurrence.data)[ncol(recurrence.data)] <- 'RecurrenceCount';

recurrence.threshold <- floor(length(all.samples)*0.9);
tmp <- merge(input.data, recurrence.data, all.x = TRUE);
tmp <- tmp[which(tmp$RecurrenceCount < recurrence.threshold),];

print(paste0("Removing ",
	nrow(recurrence.data[which(recurrence.data$RecurrenceCount > recurrence.threshold),]),
	" variants due to too high recurrence (>= 90% [n = ",
	recurrence.threshold,
	"] of samples)."
	));

mutation.data <- tmp[,keep.fields];

rm(tmp,recurrence.data);

# apply variant coding
mutation.data$Code <- variant.codes$Code[match(mutation.data$Variant_Classification, variant.codes$Classification)];
mutation.data[which(mutation.data$Code > 6),]$Code <- 9;

# get per-sample mutation counts
sample.counts <- data.frame(cbind(
	table(mutation.data$Tumor_Sample_Barcode),
	table(mutation.data[which(mutation.data$Code != 9),]$Tumor_Sample_Barcode)
	));
colnames(sample.counts) <- c('Total','Non.Silent');

if (!is.null(msi)) {
	sample.counts$MSI <- msi[rownames(sample.counts),]$Percent;
	}

# convert these to mutation rates
if (!is.null(callable.bases)) {

	sample.counts$Callable <- NA;

	for (smp in rownames(sample.counts)) {
		if (arguments$seq_type == 'wgs') {
			sample.counts[smp,]$Callable <- callable.bases[smp,]$Patient.total;
			} else {
			sample.counts[smp,]$Callable <- callable.bases[smp,]$Patient.targeted;
			}
		}

	sample.counts$SNVsPerMb <- sample.counts$Total / sample.counts$Callable * 10**6;
	sample.counts$NonSilent.Rate.Mb <- sample.counts$Non.Silent / sample.counts$Callable * 10**6;
	sample.counts <- sample.counts[order(sample.counts$SNVsPerMb, decreasing = TRUE),];
	} else {
	sample.counts <- sample.counts[order(sample.counts$Total, decreasing = TRUE),];
	}

sample.counts$Order <- 1:nrow(sample.counts);

# summarize mutations
functional.summary <- data.frame(table(mutation.data[,c('Tumor_Sample_Barcode','Code')]));
tmp <- aggregate(Freq ~ Tumor_Sample_Barcode,functional.summary,sum);
functional.summary <- merge(functional.summary, tmp, by = 'Tumor_Sample_Barcode');
functional.summary$Proportion <- functional.summary$Freq.x / functional.summary$Freq.y;
functional.summary$Tumor_Sample_Barcode <- factor(
	functional.summary$Tumor_Sample_Barcode,
	levels = rownames(sample.counts)
	);
functional.summary$Code <- factor(functional.summary$Code, levels = rev(c(1:6,9)));
rm(tmp);

alt.functional <- data.frame(table(mutation.data[which(mutation.data$Code < 9),c('Tumor_Sample_Barcode','Code')]));
if (nrow(alt.functional) > 0) {
	tmp <- aggregate(Freq ~ Tumor_Sample_Barcode, alt.functional, sum);
	alt.functional <- merge(alt.functional, tmp, by = 'Tumor_Sample_Barcode');
	alt.functional$Proportion <- alt.functional$Freq.x / alt.functional$Freq.y;
	alt.functional$Tumor_Sample_Barcode <- factor(
		alt.functional$Tumor_Sample_Barcode,
		levels = rownames(sample.counts)
		);
	alt.functional$Code <- factor(alt.functional$Code, levels = rev(c(1:6,9)));
	rm(tmp);
	} else { alt.functional <- NULL;
	}

mutation.data$Basechange <- paste0(mutation.data$Reference_Allele, '>', mutation.data$Tumor_Seq_Allele2);
if (any(input.data$Variant_Type %in% c('INS','DEL'))) {
	mutation.data[which(input.data$Variant_Type %in% c('DEL', 'INS')),]$Basechange <- 'indel';
	}
if (any(mutation.data$Basechange == 'T>G')) {
	mutation.data[which(mutation.data$Basechange == 'T>G'),]$Basechange <- 'A>C';
	}
if (any(mutation.data$Basechange == 'T>C')) {
	mutation.data[which(mutation.data$Basechange == 'T>C'),]$Basechange <- 'A>G';
	}
if (any(mutation.data$Basechange == 'T>A')) {
	mutation.data[which(mutation.data$Basechange == 'T>A'),]$Basechange <- 'A>T';
	}
if (any(mutation.data$Basechange == 'C>T')) {
	mutation.data[which(mutation.data$Basechange == 'C>T'),]$Basechange <- 'G>A';
	}
if (any(mutation.data$Basechange == 'C>G')) {
	mutation.data[which(mutation.data$Basechange == 'C>G'),]$Basechange <- 'G>C';
	}
if (any(mutation.data$Basechange == 'C>A')) {
	mutation.data[which(mutation.data$Basechange == 'C>A'),]$Basechange <- 'G>T';
	}
mutation.data$Basechange <- factor(
	mutation.data$Basechange,
	levels = rev(c('A>C','A>G','A>T','G>A','G>C','G>T','indel'))
	);
basechange.summary <- data.frame(table(mutation.data[,c('Tumor_Sample_Barcode','Basechange')]));
tmp <- aggregate(Freq ~ Tumor_Sample_Barcode, basechange.summary, sum);
basechange.summary <- merge(basechange.summary, tmp, by = 'Tumor_Sample_Barcode');
basechange.summary$Proportion <- basechange.summary$Freq.x / basechange.summary$Freq.y;
basechange.summary$Tumor_Sample_Barcode <- factor(
	basechange.summary$Tumor_Sample_Barcode,
	levels = rownames(sample.counts)
	);
rm(tmp);

# remove silent mutations
remove.idx <- which(mutation.data$Variant_Classification %in% c('Silent','Intron','IGR'));
print(paste0(
	"Removing ", length(remove.idx), " (",
	round(length(remove.idx) / nrow(mutation.data) * 100, digits = 2), " %)",
	" variants with classifications of silent/intron/IGR."
	));

mutation.data <- mutation.data[-remove.idx,];

# reduce to 1 mutation per gene per sample [taking the higher priority code]
mutation.data.trimmed <- aggregate(
	Code ~ Tumor_Sample_Barcode + Hugo_Symbol + Chromosome,
	mutation.data,
	min
	);

# reshape data
plot.data <- reshape(
	mutation.data.trimmed,
	direction = 'wide',
	timevar = 'Tumor_Sample_Barcode',
	idvar = c('Chromosome','Hugo_Symbol')
	);
colnames(plot.data) <- gsub('Code.','',colnames(plot.data));

# ensure all samples are accounted for
absent.smps <- setdiff(all.samples, colnames(plot.data));
if (length(absent.smps) > 0) { plot.data[,absent.smps] <- NA; }

# get per-gene sample counts
plot.data <- plot.data[,c('Hugo_Symbol', 'Chromosome', all.samples)];

print(paste0("Found ", nrow(plot.data), " genes with non-silent mutations."));

if (length(all.samples) > 1) {
	plot.data$Count <- apply(plot.data[,all.samples],1,function(i) { length(i[!is.na(i)]) } );
	plot.data$Priority <- apply(
		plot.data[,all.samples],1,function(i) { length(i[which(i < 4)]) } )/plot.data$Count;
	plot.data <- plot.data[order(plot.data$Count, plot.data$Priority, decreasing = TRUE),];

	if (all(is.na(plot.data$Priority))) {
		plot.data$Priority <- apply(
			plot.data[,all.samples],1,function(i) { length(i[which(i < 9)]) } )/plot.data$Count;
		plot.data <- plot.data[order(plot.data$Count, plot.data$Priority, decreasing = TRUE),];
		}

	# remove non-recurrently mutated genes
	print(paste0("Removing ",
		length(which(plot.data$Count == 1)),
		" genes with mutations in a single sample."
		));

	plot.data <- plot.data[which(plot.data$Count > 1),];

	# save recurrence summary for later
	recurrence.summary <- as.data.frame(table(plot.data$Count));
	colnames(recurrence.summary) <- c('N.samples','N.genes');

	# add MutSigCV significance
	if (!is.null(arguments$mutsig)) {

		tmp <- merge(
			plot.data,
			mutsig[,c('p','q')],
			by.x = 'Hugo_Symbol',
			by.y = 'row.names',
			all.x = TRUE
			);

		plot.data <- tmp[order(-tmp$Count, tmp$p),];
		rm(tmp);
		}

	# organize data for prettier heatmap
	heatmap.data <- t(plot.data[,all.samples]);
	heatmap.data[!is.na(heatmap.data)] <- 1;
	heatmap.data <- heatmap.data[do.call(order, transform(heatmap.data)),];

	sample.order <- rownames(heatmap.data);

	} else {
	plot.data$Count <- 1;
	sample.order <- all.samples;
	}

# remove known problem (passenger) genes
genes.to.exclude <- c('TTN','MUC17','OBSCN','MUC16','SYNE2','NEB','SYNE1');
print(paste0("Removing commonly-mutated genes (likely passenger mutations): ",
	paste(genes.to.exclude, collapse = ',')
	));

plot.data <- plot.data[which(!plot.data$Hugo_Symbol %in% genes.to.exclude),];

print(paste0(
	"Resulting list contains ",
	nrow(plot.data),
	" recurrently mutated genes (2 or more samples)."
	));

# trim down to top recurrently mutated genes (or top 20, whichever is smallest)
print("Preparing data for plotting...");

tophit.flag <- 'none';
top.count <- which(plot.data$Count > length(all.samples)*0.2);

# filter by significance if available
if (!is.null(arguments$mutsig)) {

	if (length(which(plot.data$p < 0.01)) >= 20) { threshold <- 0.01;
		} else if (length(which(plot.data$p < 0.05)) >= 20) { threshold <- 0.05;
		} else if (length(which(plot.data$p < 0.10)) >= 20) { threshold <- 0.10; }

	print(paste0("> Selecing genes with MutSigCV p-value < ", threshold));
	plot.data <- plot.data[which(plot.data$p < threshold),];
	tophit.flag <- 'mutsig';

	# else, filter by recurrence (if N is good for plotting)
	} else if (length(top.count) <= 20 & length(top.count) > 2) {
	print("> Selecting genes altered in >20% of samples");
	plot.data <- plot.data[top.count,];
	tophit.flag <- 'top';

	# likely only true for datasets with no matched normal
	} else if (nrow(plot.data[which(plot.data$Count == length(all.samples)),]) > 20) {

	if (exists('driver.genes')) {
		# plot known tumour suppressors
		print("> High recurrence rate detected; selecting known driver genes only");
		plot.data <- plot.data[which(plot.data$Hugo_Symbol %in% driver.genes$Hugo_Symbol),];
		tophit.flag <- 'driver';
		} else {
		print("> High recurrence rate detected; manual filtering suggested!");
		}
	}

if (nrow(plot.data) > 20) {
	print("Too many genes still remaining; selecting first 20 for plotting.");
	plot.data <- plot.data[1:20,];
	}

# clean up for plotting
plot.data$Label <- as.character(plot.data$Hugo_Symbol);
if (any(duplicated(plot.data$Hugo_Symbol))) {
	dup.symbols <- unique(plot.data$Hugo_Symbol[duplicated(plot.data$Hugo_Symbol)]);
	for (gene in dup.symbols) {
		tmp <- plot.data[which(plot.data$Hugo_Symbol == gene),1:2];
		new.symbols <- paste0(plot.data$Hugo_Symbol, '_', plot.data$Chromosome);
		plot.data[which(plot.data$Hugo_Symbol == gene),]$Label <- new.symbols;
		}
	}

### MAKE PLOTS #####################################################################################
# make the plot legend (mutation type/consequence)
functional.legend <- legend.grob(
	legends = list(
		legend = list(
			colours = variant.colours,
			labels = names(variant.colours)
			)
		),
	title.just = 'left',
	size = 2
	);

basechange.legend <- legend.grob(
	legends = list(
		legend = list(
			colours = basechange.colours,
			labels = c(
				expression('A' %->% 'C,T' %->% 'G'),
				expression('A' %->% 'G,T' %->% 'C'),
				expression('A' %->% 'T,T' %->% 'A'),
				expression('G' %->% 'A,C' %->% 'T'),
				expression('G' %->% 'C,C' %->% 'G'),
				expression('G' %->% 'T,C' %->% 'A'),
				'indel'
				)
			)
		),
	title.just = 'left',
	size = 2
	);

msi.legend <- legend.grob(
	legends = list(
		legend = list(
			colours = c('white','grey50','black'),
			labels = c('MSS','MSI-L','MSI-H')
			),
		legend = list(
			colours = variant.colours,
			labels = names(variant.colours)
			)
		),
	title.just = 'left',
	size = 2
	);

# grab some parameters
axis.cex <- if (length(all.samples) <= 30) { 1
	} else if (length(all.samples) <= 50) { 0.75
	} else if (length(all.samples) <= 80) { 0.5
	} else { 0 };

# create heatmap for recurrent genes (ordered by recurrence)
if (length(sample.order) == 1) {
	plot.data$Sample2 <- plot.data[,sample.order];
	sample.order <- c(sample.order, 'Sample2');
	}

create.heatmap(
	plot.data[,sample.order],
	cluster.dimensions = 'none',
	same.as.matrix = TRUE,
	xaxis.lab = if (length(all.samples) == 1) { all.samples } else { sample.order },
	xat = if (length(all.samples) == 1) { 1.5 } else { TRUE },
	yaxis.lab = plot.data$Label,
	xaxis.cex = axis.cex,
	yaxis.cex = 1,
	xaxis.tck = if (axis.cex == 0) { 0 } else { 0.2 },
	yaxis.tck = 0.2,
	xaxis.fontface = 'plain',
	yaxis.fontface = 'plain',
	axes.lwd = 1,
	grid.row = TRUE,
	force.grid.row = TRUE,
	row.colour = 'grey80',
	col.colour = 'grey80',
	row.lwd = if (length(all.samples) < 30) { 3 } else { 1 },
	col.lwd = if (length(all.samples) < 30) { 3 } else { 1 },
	grid.col = (length(all.samples) > 1),
	force.grid.col = (length(all.samples) > 1),
	print.colour.key = FALSE,
	fill.colour = 'white',
	at = seq(0,length(variant.colours),1),
	total.colours = length(variant.colours)+1,
	colour.scheme = variant.colours,
	inside.legend = if (length(all.samples) < 12) { 
		list(fun = functional.legend, x = 1.02, y = 1)
		} else { NULL },
	right.padding = if (length(all.samples) < 12) { 21 } else { 0 },
	height = 6,
	width = 8,
	resolution = 200,
	filename = generate.filename(arguments$project, 'snv_recurrent_genes','png')
	);

if (!is.null(arguments$mutsig)) {

	plot.data$Label <- factor(plot.data$Label, levels = rev(as.character(plot.data$Label)));

	create.barplot(
		Label ~ -log10(p),
		plot.data,
		plot.horizontal = TRUE,
		ylab.label = NULL,
		xlab.label = expression('-log'['10']*'(p-value)'),
		xlab.cex = 1.5,
		yaxis.fontface = 'plain',
		xaxis.fontface = 'plain',
		yaxis.cex = 1,
		xaxis.cex = 1,
		yaxis.tck = c(0.5,0),
		xaxis.tck = c(0.5,0),
		abline.v = -log10(threshold),
		abline.col = 'red',
		abline.lty = 2,
		xlimits = c(0, ceiling(max(-log10(plot.data$p))) + 1),
		height = 6,
		width = 3,
		resolution = 200,
		filename = generate.filename(arguments$project, 'MutSigCV_pvalues','png')
		);
	}

# create plot for mutation rates
tmb <- if ( (!is.null(callable.bases)) & (all(sample.counts$Callable > 0)) ) { 'SNVsPerMb'
	} else { 'Total'; }
	
ylim <- c(floor(min(log10(sample.counts[,tmb]))), ceiling(max(log10(sample.counts[,tmb]))));
yat <- seq(ylim[1], ylim[2], 1);
yaxis.labels <- 10**yat;
sample.counts$Rate <- log10(sample.counts[,tmb]);

if (ylim[2] == 1) {
	ylim <- c(0, ceiling(max(sample.counts[,tmb])));
	yat <- if (ylim[2] > 5) { seq(0,ylim[2]+1,2); } else { seq(0,ylim[2]+1,1); }
	yaxis.labels <- yat;
	sample.counts$Rate <- sample.counts[,tmb];
	}

rate.plot <- create.scatterplot(
	Rate ~ Order,
	sample.counts,
	xaxis.lab = rep('', nrow(sample.counts)+1),
	yaxis.cex = 1,
	xaxis.tck = 0,
	yaxis.tck = c(0.5,0),
	yaxis.fontface = 'plain',
	axes.lwd = 1,
	ylab.label = if ('SNVsPerMb' == tmb) { 'SNVs/Mbp' } else { 'Total SNVs' },
	ylab.cex = 1.2,
	ylimits = ylim,
	yat = yat,
	yaxis.lab = yaxis.labels,
	xlab.label = NULL,
	xlimits = c(0.5,nrow(sample.counts)+0.5),
	xat = seq(0,nrow(sample.counts),1)
	);

# create plot for MSI (if available)
if (!is.null(msi)) {
	msi.plot.data <- data.frame(MSI = sample.counts$MSI, MSI2 = sample.counts$MSI);
	msi.plot <- create.heatmap(
		msi.plot.data,
		cluster.dimensions = 'none',
		yaxis.lab = 'MSI',
		yat = 1.5,
		xaxis.lab = rep('',nrow(msi.plot.data)),
		xaxis.tck = 0,
		yaxis.fontface = 'plain',
		yaxis.cex = 1,
		axes.lwd = 1,
		yaxis.tck = c(0.5,0),
		colour.scheme = c('white','black'),
		total.colours = 4,
		at = c(0,10,20,100),
		print.colour.key = FALSE
		);
	}

# create plot for functional summary
mutation.type.plot <- create.barplot(
	Proportion ~ Tumor_Sample_Barcode,
	functional.summary,
	groups = functional.summary$Code,
	stack = TRUE,
	col = rev(variant.colours),
	xaxis.lab = rep('',length(all.samples)),
	xlimits = c(0.5, length(all.samples)+0.5),
	xat = seq(1,length(all.samples)),
	yaxis.tck = c(0.5,0),
	xaxis.tck = 0,
	xaxis.fontface = 'plain',
	yaxis.fontface = 'plain',
	ylab.label = 'Proportion',
	ylab.cex = 1.2,
	xlab.label = NULL,
	ylimits = c(0,1),
	yat = seq(0,1,0.5),
	yaxis.cex = 1,
	axes.lwd = 1,
	top.padding = 0
	);

if (!is.null(alt.functional)) {

	if (any(is.na(alt.functional$Proportion))) {
		alt.functional[is.na(alt.functional$Proportion),]$Proportion <- 0;
		}

	functional.plot <- create.barplot(
		Proportion ~ Tumor_Sample_Barcode,
		alt.functional,
		groups = alt.functional$Code,
		stack = TRUE,
		col = rev(variant.colours),
		xaxis.lab = rep('',length(all.samples)),
		xlimits = c(0.5, length(all.samples)+0.5),
		xat = seq(1,length(all.samples)),
		yaxis.tck = c(0.5,0),
		xaxis.tck = 0,
		xaxis.fontface = 'plain',
		yaxis.fontface = 'plain',
		ylab.label = 'Proportion',
		ylab.cex = 1.2,
		xlab.label = NULL,
		ylimits = c(0,1),
		yat = seq(0,1,0.5),
		yaxis.cex = 1,
		axes.lwd = 1,
		top.padding = 0
		);
	}

# create plot for basechange summary
basechange.plot <- create.barplot(
	Proportion ~ Tumor_Sample_Barcode,
	basechange.summary,
	groups = basechange.summary$Basechange,
	stack = TRUE,
	col = rev(basechange.colours),
	xaxis.lab = levels(basechange.summary$Tumor_Sample_Barcode),
	xaxis.rot = if (length(all.samples) == 1) { 0 } else { 90 },
	xlimits = c(0.5, length(all.samples)+0.5),
	xat = seq(1,length(all.samples)),
	yaxis.tck = c(0.5,0),
	xaxis.tck = 0,
	xaxis.fontface = 'plain',
	yaxis.fontface = 'plain',
	ylab.label = 'Proportion',
	ylab.cex = 1.2,
	xlab.label = NULL,
	ylimits = c(0,1),
	yat = seq(0,1,0.5),
	yaxis.cex = 1,
	xaxis.cex = axis.cex,
	axes.lwd = 1,
	top.padding = 0,
	legend = list(
		right = list(fun = basechange.legend)
		)
	);

# combine them!
if (arguments$seq_type == 'wgs') {

	if (is.null(alt.functional)) {
		functional.plot <- mutation.type.plot;
		}

	if (is.null(msi)) { plot.list <- list(rate.plot, functional.plot, basechange.plot);
		} else {
		plot.list <- list(rate.plot, msi.plot, functional.plot, basechange.plot);
		}

	create.multipanelplot(
		plot.objects = plot.list,
		height = 10,
		width = 8,
		resolution = 200,
		filename = generate.filename(arguments$project, 'mutation_summary','png'),
		plot.objects.heights = if (length(plot.list) == 3) { c(2,3,4) } else { c(2,0.5,2,4) },
		left.legend.padding = 0,
		right.legend.padding = 0,
		top.legend.padding = 0,
		bottom.legend.padding = 0,
		right.padding = 2,
		y.spacing = -1,
		ylab.axis.padding = 0.5,
		legend = list(
			inside = if (is.null(msi)) {
				list(fun = functional.legend, x = 0.88, y = 0.65)
				} else {
				list(fun = msi.legend, x = 0.88, y = 0.66)
				}
			)
		);

	} else {

	if (is.null(msi)) {
		if (is.null(alt.functional)) {
			plot.list <- list(rate.plot, mutation.type.plot, basechange.plot);
			} else {
			plot.list <- list(rate.plot, mutation.type.plot, functional.plot, basechange.plot);
			}
		} else {
		if (is.null(alt.functional)) {
			plot.list <- list(rate.plot, msi.plot, mutation.type.plot, basechange.plot);
			} else {
			plot.list <- list(rate.plot, msi.plot, mutation.type.plot, functional.plot, basechange.plot);
			}
		}

	create.multipanelplot(
		plot.objects = plot.list,
		height = 10,
		width = 8,
		resolution = 200,
		filename = generate.filename(arguments$project, 'mutation_summary','png'),
		plot.objects.heights = if (length(plot.list) == 3) { c(2,3,4) } else if (length(plot.list) == 4) { c(1.5,2,2,4) } else { c(1.5,0.5,2,2,4) },
		left.legend.padding = 0,
		right.legend.padding = 0,
		top.legend.padding = 0,
		bottom.legend.padding = 0,
		right.padding = 2,
		y.spacing = -1,
		ylab.axis.padding = 0.5,
		legend = list(
			inside = if (is.null(msi)) {
				list(fun = functional.legend, x = 0.88, y = 0.65)
				} else {
				list(fun = msi.legend, x = 0.88, y = 0.75)
				}
			)
		);
	}

save(
	sample.counts,
	functional.summary,
	basechange.summary,
	plot.data,
	variant.colours,
	file = generate.filename(arguments$project, 'mutation_summary', 'RData')
	);

### LATEX ##########################################################################################
# write some captions
if (arguments$seq_type == 'wgs') {
	summary.caption <- if (is.null(msi)) { "Summary of short somatic variants (SNVs, indels) for each sample. From top to bottom: mutation rate (SNVs and INDELs per Mbp); proportion of all non-silent mutations with indicated functional consequence; proportion of total mutations with the indicated mutation type.";
		} else { "Summary of short somatic variants (SNVs, indels) for each sample. From top to bottom: mutation rate (SNVs and INDELs per Mbp); predicted MSI status; proportion of all non-silent mutations with indicated functional consequence; proportion of total mutations with the indicated mutation type. MSI status based on percent of microsatellite sites that are unstable (MSI-H $>$20\\%, MSI-L $>$10\\%).";
		}
	} else {
	summary.caption <- if (is.null(msi)) { "Summary of short somatic variants (SNVs, indels) for each sample. From top to bottom: mutation rate (SNVs and INDELs per Mbp); proportion of total mutations with indicated functional consequence; proportion of all non-silent mutations with indicated functional consequence; proportion of total mutations with the indicated mutation type.";
		} else { "Summary of short somatic variants (SNVs, indels) for each sample. From top to bottom: mutation rate (SNVs and INDELs per Mbp); predicted MSI status; proportion of total mutations with indicated functional consequence; proportion of all non-silent mutations with indicated functional consequence; proportion of total mutations with the indicated mutation type. MSI status based on percent of microsatellite sites that are unstable (MSI-H $>$20\\%, MSI-L $>$10\\%).";
		}
	}

if ('top' == tophit.flag) {
	recurrence.caption <- "Summary of the most frequently mutated genes across the cohort. Figure shows genes with mutations detected in $>$20\\% of samples.";
	} else if ('mutsig' == tophit.flag) {
	recurrence.caption <- paste0(
		"Summary of the most frequently mutated genes across the cohort.",
		" Figure shows genes with significant MutSigCV result (p $<$ ", threshold, ")."
		);
	} else if ('driver' == tophit.flag) {
	recurrence.caption <- "Summary of the most frequently mutated known driver genes across the cohort.";
	} else {
	recurrence.caption <- "Summary of the most frequently mutated genes across the cohort.";
	}

recurrence.caption <- paste(
	recurrence.caption, 
	"Colours indicate predicted functional consequence (white = no mutation detected).",
	"Gene set is truncated to top 20 hits where necessary."
	);

# write for latex
write("\\section{SNV Summary}", file = 'somatic_snv_summary.tex');

# first, check for mutation_overlap plot
tool.overlap.plot <- rev(sort(list.files(pattern = 'SNV_tool_overlap.png')));
if (length(tool.overlap.plot) > 0) {
	write("\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\begin{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\includegraphics[width=1\\textwidth]{",
		getwd(), '/',
		tool.overlap.plot[1], '}'
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\caption{UpSet plot showing overlap across SNV/INDEL variant callers.}"
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{figure}\n\\pagebreak\n", file = 'somatic_snv_summary.tex', append = TRUE);
	}

overlap.plot <- rev(sort(list.files(pattern = 'mutation_overlap.png')));
if (length(overlap.plot) > 0) {
	write("\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\begin{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\includegraphics[height=0.85\\textheight]{",
		getwd(), '/',
		overlap.plot[1], '}'
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\caption{From top to bottom: number of variants called by each tool (Mutect, MuTect2, SomaticSniper, Strelka, VarDict and VarScan) and the ensemble variants carried forward.}"
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{figure}\n\\pagebreak\n", file = 'somatic_snv_summary.tex', append = TRUE);
	}

# describe filtering (if any tumour-only)
if ( (grepl('oncokb_annotated_filtered.tsv', arguments$input)) & (any(input.data$FLAG.tumour_only))) {
	write('Ensemble calls were filtered to remove probable false positives from tumour-only samples using the following criteria:',	file = 'somatic_snv_summary.tex', append = TRUE);

	write("\\begin{itemize}", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\item remove any variant with AF $>$ 0.001 in any population", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\item remove any variant with VAF $<$ 0.05", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\item keep any variant identified by OncoKB as oncogenic or ", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\item keep any variant identified by OncoKB as Loss-of-function, Likely Loss-of-function, Gain-of-function, Likely Gain-of-function or Switch-of-function", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{itemize}\n\\pagebreak\n", file = 'somatic_snv_summary.tex', append = TRUE);
	}

# were any recurrently-mutated genes plotted?
if (nrow(plot.data) == 0) {
	write("No genes were recurrently mutated across the cohort.", file = 'somatic_snv_summary.tex', append = TRUE);
	} else {

	# add per-sample summary (snv/mbp, proportion basechange/functional, msi, ...)
	write("\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\begin{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\includegraphics[height=0.8\\textheight]{",
		getwd(), '/',
		generate.filename(arguments$project, 'mutation_summary','png'), '}'
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\caption{", summary.caption, "}"
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{figure}\n", file = 'somatic_snv_summary.tex', append = TRUE);

	write("\\pagebreak\n", file = 'somatic_snv_summary.tex', append = TRUE);

	if (exists('recurrence.summary')) {
		caption <- 'Summary of recurrently-mutated genes across the cohort. Table shows number of genes with functionally relevant mutations in N samples.';
		print(
			xtable(
				rev(recurrence.summary)[1:(min(nrow(recurrence.summary),10)),],
				caption = caption 
				),
			file = 'somatic_snv_summary.tex',
			include.rownames = FALSE,
			append = TRUE
			);
		}

	# add gene x sample heatmap
	if (nrow(recurrence.summary) < 7) {
		write("\n\\vspace{1.0cm}\n\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
		} else {
		write("\n\\pagebreak\n\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
		}

	write("\\begin{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\includegraphics[width=0.95\\textwidth]{",
		getwd(), '/',
		generate.filename(arguments$project, 'snv_recurrent_genes','png'), '}'
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{center}", file = 'somatic_snv_summary.tex', append = TRUE);
	write(paste0(
		"\\caption{", recurrence.caption, "}"
		), file = 'somatic_snv_summary.tex', append = TRUE);
	write("\\end{figure}\n", file = 'somatic_snv_summary.tex', append = TRUE);

	# add mutsig barplot
	if (!is.null(arguments$mutsig)) {
		write("\n\\pagebreak\n\\begin{figure}[h!]", file = 'somatic_snv_summary.tex', append = TRUE);
		write("\n\\begin{center}", file = 'somatic_snv_summary.tex', append = TRUE);
		write(paste0(
			"\\includegraphics[height=0.6\\textheight]{",
			getwd(), '/',
			generate.filename(arguments$project, 'MutSigCV_pvalues','png'), '}'
			), file = 'somatic_snv_summary.tex', append = TRUE);
		write("\\end{center}", file = 'somatic_snv_summary.tex', append = TRUE);
		write(
			"\\caption{MutSigCV p-values for the most frequently mutated genes shown above.}",
			file = 'somatic_snv_summary.tex', append = TRUE);
		write("\\end{figure}\n", file = 'somatic_snv_summary.tex', append = TRUE);
		}
	}

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('MutationSummary','SessionProfile','txt'));
